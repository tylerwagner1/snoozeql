---
phase: 12-metrics-retention
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/metrics/retention.go
  - internal/metrics/store.go
  - cmd/server/main.go
autonomous: true

must_haves:
  truths:
    - "Metrics older than 7 days are automatically deleted"
    - "Cleanup runs on startup (after delay) and every 24 hours thereafter"
    - "Cleanup skips if already ran within 24 hours (survives restarts)"
    - "Cleanup runs without affecting application performance (batched deletes)"
  artifacts:
    - path: "internal/metrics/retention.go"
      provides: "RetentionCleaner service with RunContinuous pattern"
      min_lines: 80
    - path: "internal/metrics/store.go"
      provides: "Updated DeleteOldMetrics with batch support"
      contains: "DeleteOldMetrics"
    - path: "cmd/server/main.go"
      provides: "RetentionCleaner initialization and startup"
      contains: "RetentionCleaner"
  key_links:
    - from: "cmd/server/main.go"
      to: "internal/metrics/retention.go"
      via: "go retentionCleaner.RunContinuous(ctx)"
      pattern: "retentionCleaner.*RunContinuous"
    - from: "internal/metrics/retention.go"
      to: "internal/metrics/store.go"
      via: "DeleteOldMetrics call in cleanup loop"
      pattern: "DeleteOldMetrics"
    - from: "internal/metrics/retention.go"
      to: "settings table"
      via: "last run timestamp tracking"
      pattern: "metrics_retention_last_run"
---

<objective>
Implement automatic cleanup of old metrics data with 7-day retention.

Purpose: Keep the database manageable by automatically deleting metrics older than 7 days. Cleanup runs on startup (after 7-minute delay) and every 24 hours thereafter, with last-run tracking to prevent duplicate runs across restarts.

Output: A `RetentionCleaner` service that follows the existing `MetricsCollector.RunContinuous()` pattern, deletes in batches to avoid table locking, and tracks last run timestamp in the settings table.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-metrics-retention/12-CONTEXT.md
@.planning/phases/12-metrics-retention/12-RESEARCH.md
@internal/metrics/collector.go (pattern for RunContinuous)
@internal/metrics/store.go (existing DeleteOldMetrics method)
@cmd/server/main.go (service initialization pattern)
@deployments/docker/migrations/001_base_schema.sql (settings table schema)
@deployments/docker/migrations/005_metrics_hourly.sql (metrics_hourly schema with hour column and index)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RetentionCleaner service</name>
  <files>internal/metrics/retention.go</files>
  <action>
Create `internal/metrics/retention.go` with a `RetentionCleaner` service following the existing `MetricsCollector.RunContinuous()` pattern from collector.go.

**Constants:**
- `retentionDays = 7` (hard-coded per CONTEXT.md)
- `cleanupBatchSize = 1000` (rows per batch)
- `startupDelay = 7 * time.Minute` (within 5-10 min range per CONTEXT.md)
- `cleanupInterval = 24 * time.Hour`
- `settingsKey = "metrics_retention_last_run"`

**Struct:**
```go
type RetentionCleaner struct {
    metricsStore *MetricsStore
    db           *store.Postgres
}
```

**Methods:**
1. `NewRetentionCleaner(metricsStore *MetricsStore, db *store.Postgres) *RetentionCleaner`

2. `RunContinuous(ctx context.Context)` - Main goroutine loop:
   - Wait for startup delay (7 minutes) with context awareness
   - After delay, run cleanup immediately
   - Start 24-hour ticker
   - On each tick, run cleanup
   - Log only on errors (not on success per CONTEXT.md)

3. `runCleanup(ctx context.Context) error`:
   - Get last run time from settings
   - If last run < 24 hours ago, skip (return nil)
   - Calculate cutoff: `time.Now().UTC().Add(-7 * 24 * time.Hour)`
   - Call `deleteInBatches(ctx, cutoff)`
   - On success, update last run timestamp
   - On error, return error (caller logs, no retry per CONTEXT.md)

4. `deleteInBatches(ctx context.Context, cutoff time.Time) error`:
   - Loop calling DeleteOldMetrics with batchSize limit
   - Break when deleted < batchSize (no more rows)
   - Add 100ms pause between batches with context check
   - Return error if any batch fails

5. `getLastRunTime(ctx context.Context) (time.Time, error)`:
   - Query settings table: `SELECT value->>'timestamp' FROM settings WHERE key = $1`
   - Parse as RFC3339
   - Return zero time if not found (triggers first run)

6. `setLastRunTime(ctx context.Context, t time.Time) error`:
   - Upsert settings: `INSERT INTO settings (key, value, scope, updated_at) VALUES ($1, jsonb_build_object('timestamp', $2::text), 'global', NOW()) ON CONFLICT (key) DO UPDATE SET value = ..., updated_at = NOW()`

**Important patterns:**
- Use `time.Now().UTC()` for all timestamp comparisons (per RESEARCH.md pitfalls)
- Check `ctx.Done()` in startup delay and between batches
- Delete based on `hour` column (metric timestamp), not `created_at` (per CONTEXT.md)
  </action>
  <verify>
`go build ./...` compiles without errors.
  </verify>
  <done>
retention.go exists with RetentionCleaner struct and all methods implemented following the collector.go pattern.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update DeleteOldMetrics for batch support</name>
  <files>internal/metrics/store.go</files>
  <action>
Update the existing `DeleteOldMetrics` method in `internal/metrics/store.go` to support batched deletes.

**Current signature (line 112):**
```go
func (s *MetricsStore) DeleteOldMetrics(ctx context.Context, before time.Time) (int64, error) {
    return s.db.Exec(ctx, "DELETE FROM metrics_hourly WHERE hour < $1", before)
}
```

**New signature:**
```go
func (s *MetricsStore) DeleteOldMetrics(ctx context.Context, before time.Time, limit int) (int64, error)
```

**New implementation:**
```go
func (s *MetricsStore) DeleteOldMetrics(ctx context.Context, before time.Time, limit int) (int64, error) {
    // Use subquery with LIMIT to batch deletes and avoid table locks
    query := `
        DELETE FROM metrics_hourly 
        WHERE id IN (
            SELECT id FROM metrics_hourly 
            WHERE hour < $1 
            LIMIT $2
        )`
    return s.db.Exec(ctx, query, before, limit)
}
```

This uses a subquery pattern for batched deletes which is PostgreSQL-friendly and leverages the existing `idx_metrics_hourly_hour` index.

**Why subquery instead of direct LIMIT:**
PostgreSQL doesn't support `DELETE ... LIMIT` directly. The subquery pattern is the standard approach for batched deletes in PostgreSQL.
  </action>
  <verify>
`go build ./...` compiles without errors.
  </verify>
  <done>
DeleteOldMetrics updated to accept limit parameter and uses subquery pattern for batched deletes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate RetentionCleaner in main.go</name>
  <files>cmd/server/main.go</files>
  <action>
Add RetentionCleaner initialization and startup to `cmd/server/main.go`, following the existing MetricsCollector pattern.

**Location:** After the metrics collector initialization block (around line 214-215 where `metricsCollector.RunContinuous(ctx)` is started).

**Add after line 215:**
```go
// Start metrics retention cleanup in background
retentionCleaner := metrics.NewRetentionCleaner(metricsStore, db)
go retentionCleaner.RunContinuous(ctx)
log.Printf("✓ Started metrics retention cleaner (7-day retention, 24h interval)")
```

**Why this location:**
- After metricsStore is initialized (line 191)
- After db is available (line 82-86)
- Same pattern as metricsCollector initialization (lines 192-215)
- Shares context with other background services

**No global variable needed:** Unlike discoveryService/metricsCollector, the retention cleaner doesn't need to be accessed by API handlers, so no global declaration is required.
  </action>
  <verify>
1. `go build ./...` compiles without errors
2. `go run cmd/server/main.go` starts and logs "Started metrics retention cleaner" message
  </verify>
  <done>
RetentionCleaner initialized and started as background goroutine in main.go, with startup log message visible.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build verification:** `go build ./...` succeeds
2. **Startup verification:** `go run cmd/server/main.go` shows:
   - "✓ Started metrics retention cleaner (7-day retention, 24h interval)"
3. **Code inspection:**
   - `internal/metrics/retention.go` exists with ~100+ lines
   - `RetentionCleaner` struct and `RunContinuous` method present
   - Settings key "metrics_retention_last_run" used for tracking
   - Delete uses batch limit of 1000
   - 7-day retention hardcoded (not configurable)
</verification>

<success_criteria>
- [x] `internal/metrics/retention.go` created with RetentionCleaner service
- [x] `RunContinuous` follows existing collector.go pattern (startup delay, ticker, context-aware)
- [x] Cleanup skips if ran within 24 hours (checked via settings table)
- [x] Deletes in batches of 1000 with 100ms pause between batches
- [x] Uses `hour` column for retention cutoff (not `created_at`)
- [x] `DeleteOldMetrics` updated with limit parameter
- [x] main.go starts RetentionCleaner alongside MetricsCollector
- [x] Logs only on errors (no success messages per CONTEXT.md)
- [x] Requirement METR-03 satisfied: "Metrics retention is enforced at 7 days"
</success_criteria>

<output>
After completion, create `.planning/phases/12-metrics-retention/12-01-SUMMARY.md`
</output>
