---
phase: 06-intelligent-recommendations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/analyzer/recommendation.go
  - internal/api/handlers/recommendations.go
  - internal/api/routes.go
  - cmd/server/main.go
autonomous: true

must_haves:
  truths:
    - "System analyzes activity metrics and generates potential sleep schedule recommendations"
    - "Recommendations persist in database with pending status"
    - "API returns recommendations sorted by savings potential"
  artifacts:
    - path: "internal/analyzer/recommendation.go"
      provides: "Recommendation generation from IdleWindow patterns"
      exports: ["GenerateRecommendations", "idleWindowToRecommendation"]
    - path: "internal/api/handlers/recommendations.go"
      provides: "API handlers for recommendation CRUD and actions"
      exports: ["RecommendationHandler", "GetAllRecommendations", "GenerateRecommendations", "DismissRecommendation", "ConfirmRecommendation"]
  key_links:
    - from: "internal/analyzer/recommendation.go"
      to: "internal/analyzer/patterns.go"
      via: "IdleWindow type usage"
      pattern: "analyzer\\.IdleWindow"
    - from: "internal/api/handlers/recommendations.go"
      to: "internal/store/postgres.go"
      via: "RecommendationStore usage"
      pattern: "store\\.RecommendationStore"
---

<objective>
Implement backend recommendation generation that converts detected idle patterns into actionable schedule recommendations.

Purpose: Enable the system to analyze collected metrics and generate schedule recommendations for instances with detected idle windows, including CRON schedule suggestions and estimated savings.

Output: API endpoints for listing, generating, dismissing, and confirming recommendations.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-intelligent-recommendations/06-CONTEXT.md
@.planning/phases/06-intelligent-recommendations/06-RESEARCH.md

# Existing code to extend
@internal/analyzer/analyzer.go
@internal/analyzer/patterns.go
@internal/store/postgres.go
@internal/models/models.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create recommendation generation logic</name>
  <files>internal/analyzer/recommendation.go</files>
  <action>
Create internal/analyzer/recommendation.go with recommendation generation logic:

1. Add GenerateRecommendations method to Analyzer that:
   - Calls existing AnalyzeAllInstances() to get activity patterns
   - For each instance with IdleWindows, check if pending recommendation already exists (skip if so)
   - Convert best IdleWindow (highest confidence) to Recommendation using idleWindowToRecommendation()
   - Store new recommendations with status "pending"
   - Return list of newly created recommendations

2. Add idleWindowToRecommendation helper that:
   - Takes instance (models.Instance) and IdleWindow
   - Generates SuggestedSchedule JSONB with:
     - timezone: "UTC" (default)
     - sleep_cron: Generated from IdleWindow.StartHour (e.g., "0 22 * * 1-5" for hour 22 on weekdays)
     - wake_cron: Generated from IdleWindow.EndHour (e.g., "0 6 * * 1-5" for hour 6 on weekdays)
   - Generates DetectedPattern JSONB with:
     - idle_start_hour: IdleWindow.StartHour
     - idle_end_hour: IdleWindow.EndHour  
     - days_of_week: Convert []time.Weekday to []string
     - avg_cpu: IdleWindow.AvgCPU
     - confidence: IdleWindow.Confidence
   - Sets ConfidenceScore from IdleWindow.Confidence (0-1 scale, multiply by 100 for display)
   - Returns models.Recommendation with InstanceID set to instance.ID (NOT ProviderID - this is critical per RESEARCH.md pitfall #1)

3. Add calculateEstimatedDailySavings helper that:
   - Takes instance.HourlyCostCents and idle window duration
   - Returns estimated daily savings in cents: (idle_hours * hourly_cost_cents)

4. Add generateCronFromHour helper that:
   - Takes hour (int) and days ([]time.Weekday)
   - Returns CRON expression string (e.g., "0 22 * * 1-5")
   - Handle overnight windows correctly (if EndHour < StartHour)

Use json.Marshal for JSONB fields (DetectedPattern, SuggestedSchedule) per RESEARCH.md pitfall #2.
  </action>
  <verify>
Run: `go build ./...` - should compile without errors
Run: `go vet ./internal/analyzer/...` - should pass
  </verify>
  <done>
GenerateRecommendations method exists and compiles, converts IdleWindow to Recommendation with proper CRON schedules and savings estimates.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement recommendation API handlers</name>
  <files>internal/api/handlers/recommendations.go, internal/api/routes.go, cmd/server/main.go</files>
  <action>
Update internal/api/handlers/recommendations.go to implement full handler:

1. Create RecommendationHandler struct with:
   - store: *store.RecommendationStore
   - instanceStore: *store.InstanceStore
   - scheduleStore: *store.ScheduleStore
   - analyzer: *analyzer.Analyzer

2. Implement GetAllRecommendations (GET /api/v1/recommendations):
   - Accept optional ?status= query param (default: "pending")
   - Call store.ListRecommendations(status)
   - Enrich each recommendation with instance details (name, provider, region, engine, hourly_cost_cents)
   - Calculate estimated_daily_savings using idle window hours * hourly_cost_cents / 100
   - Sort by estimated_daily_savings descending (highest savings first per CONTEXT.md)
   - Return enriched array

3. Implement GenerateRecommendations (POST /api/v1/recommendations/generate):
   - Call analyzer.GenerateRecommendations(ctx)
   - Return JSON with {created: N, message: "Generated N new recommendations"}

4. Implement DismissRecommendation (POST /api/v1/recommendations/{id}/dismiss):
   - Get recommendation by ID
   - Update status to "dismissed"
   - Call store.UpdateRecommendation()
   - Return 200 OK

5. Implement ConfirmRecommendation (POST /api/v1/recommendations/{id}/confirm):
   - Get recommendation by ID
   - Parse SuggestedSchedule JSONB
   - Get instance details from instanceStore
   - Create new Schedule with:
     - Name: "AI Suggested: {instance.Name}"
     - Description: "Auto-generated from activity pattern analysis"
     - Timezone, SleepCron, WakeCron from SuggestedSchedule
     - Selectors: [{name: {pattern: instance.Name, type: "exact"}}]
     - Enabled: true
   - Save schedule via scheduleStore.CreateSchedule()
   - Update recommendation status to "approved"
   - Return {schedule_id: "..."} 

6. Update routes.go to register new endpoints:
   - GET /api/v1/recommendations
   - POST /api/v1/recommendations/generate
   - POST /api/v1/recommendations/{id}/dismiss
   - POST /api/v1/recommendations/{id}/confirm

7. Update cmd/server/main.go to:
   - Create RecommendationHandler with required stores and analyzer
   - Register handler with routes
  </action>
  <verify>
Run: `go build ./cmd/server/...` - should compile without errors
Run: `curl http://localhost:8080/api/v1/recommendations` - should return empty array []
  </verify>
  <done>
API endpoints compile and GET /recommendations returns empty array. Handler is wired into main.go and routes.go.
  </done>
</task>

</tasks>

<verification>
After completing both tasks:
1. `go build ./...` compiles successfully
2. `go test ./internal/analyzer/...` passes
3. Server starts: `go run cmd/server/main.go`
4. GET /api/v1/recommendations returns []
5. POST /api/v1/recommendations/generate returns {created: 0, message: "Generated 0 new recommendations"} (no instances yet)
</verification>

<success_criteria>
- Backend can generate recommendations from existing idle window patterns
- Recommendations stored with pending status
- API returns recommendations enriched with instance details and sorted by savings
- Dismiss and Confirm actions update recommendation status and create schedules
</success_criteria>

<output>
After completion, create `.planning/phases/06-intelligent-recommendations/06-01-SUMMARY.md`
</output>
