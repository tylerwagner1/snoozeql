---
phase: 01-multi-cloud-discovery
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - cmd/server/main.go
  - internal/provider/gcp/cloudsql.go
  - internal/provider/registry.go
autonomous: true

must_haves:
  truths:
    - "Multiple AWS accounts in same region don't collide in provider registry"
    - "GCP provider accepts service account JSON credentials"
    - "Providers are re-registered when cloud accounts are added or deleted"
  artifacts:
    - path: "internal/provider/registry.go"
      provides: "Account-aware provider key format"
      contains: "fmt.Sprintf"
    - path: "internal/provider/gcp/cloudsql.go"
      provides: "Service account JSON credential support"
      contains: "option.WithCredentialsJSON"
    - path: "cmd/server/main.go"
      provides: "Provider registration with account ID in key"
      contains: "account.ID"
  key_links:
    - from: "cmd/server/main.go"
      to: "internal/provider/registry.go"
      via: "Register with account-aware key"
      pattern: "providerRegistry\\.Register"
---

<objective>
Fix multi-account provider registration and add GCP service account credential support.

Purpose: Current provider key format `aws_region` causes collisions when multiple AWS accounts exist in the same region. GCP provider doesn't accept service account JSON from frontend. This plan fixes both issues.

Output: Account-aware provider keys preventing collisions, working GCP service account JSON authentication.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-multi-cloud-discovery/01-RESEARCH.md

@cmd/server/main.go
@internal/provider/gcp/cloudsql.go
@internal/provider/registry.go
@internal/provider/aws/rds.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix provider key format to include account ID</name>
  <files>cmd/server/main.go</files>
  <action>
Update provider registration in `main.go` to use account-aware keys:

1. Change provider key format from `"aws_" + region` to include account ID:
   ```go
   providerKey := fmt.Sprintf("aws_%s_%s", account.ID, region)
   ```
   This prevents collisions when multiple accounts have same region.

2. Update the log message to show the full provider key:
   ```go
   log.Printf("✓ Registered AWS provider: %s (account: %s, region: %s)", providerKey, account.Name, region)
   ```

3. Same pattern for GCP when that registration code is added:
   ```go
   providerKey := fmt.Sprintf("gcp_%s", account.ID)
   ```

4. Ensure instance.Provider field stores the full provider key (e.g., "aws_uuid_us-east-1") so start/stop operations can find the correct provider.

Note: The AWS RDS provider's ListDatabases sets instance.Provider = "aws" in dbInstanceToModel. This is overwritten in the registry's ListAllDatabases with the correct provider key. Verify this flow works correctly.
  </action>
  <verify>
`go build ./...` compiles. Server logs show account ID in provider keys. With multiple AWS accounts configured for same region, both register without collision.
  </verify>
  <done>
Provider keys include account ID preventing multi-account collisions. Log messages show full provider key.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add GCP service account JSON credential support</name>
  <files>internal/provider/gcp/cloudsql.go</files>
  <action>
Update `NewCloudSQLProvider` to accept and use service account JSON credentials:

1. Change function signature to accept credentials:
   ```go
   func NewCloudSQLProvider(projectID, region string, managedTags []string, serviceAccountJSON string) (*CloudSQLProvider, error)
   ```

2. Create GCP client with credentials JSON:
   ```go
   import "google.golang.org/api/option"
   
   var service *cloudsql.Service
   var err error
   
   if serviceAccountJSON != "" {
       service, err = cloudsql.NewService(context.Background(), 
           option.WithCredentialsJSON([]byte(serviceAccountJSON)))
   } else {
       // Fall back to ADC (Application Default Credentials)
       service, err = cloudsql.NewService(context.Background())
   }
   ```

3. Add a `TestConnection` method similar to AWS provider:
   ```go
   func (p *CloudSQLProvider) TestConnection(ctx context.Context) error {
       _, err := p.sqlAdminService.Instances.List(p.projectID).Context(ctx).MaxResults(1).Do()
       if err != nil {
           return fmt.Errorf("failed to test GCP connection: %w", err)
       }
       return nil
   }
   ```

Import `google.golang.org/api/option` package.
  </action>
  <verify>
`go build ./...` compiles. GCP provider can be created with service account JSON string.
  </verify>
  <done>
GCP CloudSQLProvider accepts serviceAccountJSON parameter and creates authenticated client. TestConnection method added.
  </done>
</task>

<task type="auto">
  <name>Task 3: Register GCP providers and handle dynamic re-registration</name>
  <files>cmd/server/main.go, internal/provider/registry.go</files>
  <action>
1. In `cmd/server/main.go`, add GCP provider registration in the cloud accounts loop:
   ```go
   if account.Provider == "gcp" {
       // Extract GCP credentials
       projectID, _ := account.Credentials["gcp_project_id"].(string)
       serviceAccountKey, _ := account.Credentials["gcp_service_account_key"].(string)
       
       if projectID == "" {
           log.Printf("Warning: Skipping GCP account %s - missing project ID", account.Name)
           continue
       }
       
       gcpProvider, err := gcpprovider.NewCloudSQLProvider(projectID, "", []string{}, serviceAccountKey)
       if err != nil {
           log.Printf("Warning: Failed to create GCP provider for %s: %v", account.Name, err)
           continue
       }
       
       providerKey := fmt.Sprintf("gcp_%s", account.ID)
       providerRegistry.Register(providerKey, gcpProvider)
       log.Printf("✓ Registered GCP provider: %s (account: %s, project: %s)", providerKey, account.Name, projectID)
   }
   ```

2. Add import for GCP provider:
   ```go
   gcpprovider "snoozeql/internal/provider/gcp"
   ```

3. In `registry.go`, add `Unregister` method for dynamic updates:
   ```go
   func (r *Registry) Unregister(name string) {
       r.mu.Lock()
       defer r.mu.Unlock()
       delete(r.Providers, name)
   }
   ```

4. Consider: When cloud account is created/deleted via API, providers should be re-registered. For now, add a TODO comment in the POST /cloud-accounts handler noting that a server restart is required for new accounts to take effect. Full dynamic registration can be Phase 2 scope.
  </action>
  <verify>
`go build ./...` compiles. Server can register both AWS and GCP providers. GCP accounts with service account JSON are registered successfully.
  </verify>
  <done>
GCP providers are registered from cloud accounts. Provider key includes account ID. Unregister method exists for future dynamic updates. TODO comment notes restart requirement.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `go build ./...` compiles without errors
2. Server starts with mixed AWS/GCP accounts
3. Two AWS accounts with same region both register successfully (unique keys)
4. GCP account with service account JSON credential registers and connects
5. `curl http://localhost:8080/api/v1/instances` returns instances from both AWS and GCP
</verification>

<success_criteria>
- Provider keys include account ID (e.g., "aws_uuid_us-east-1", "gcp_uuid")
- Multiple accounts for same region don't collide
- GCP provider accepts serviceAccountJSON parameter
- GCP providers are registered from database cloud accounts
- Server logs show correct provider registration with account info
</success_criteria>

<output>
After completion, create `.planning/phases/01-multi-cloud-discovery/01-02-SUMMARY.md`
</output>
