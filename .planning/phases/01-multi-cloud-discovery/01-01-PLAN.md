---
phase: 01-multi-cloud-discovery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/store/postgres.go
  - internal/discovery/discovery.go
  - internal/models/models.go
  - deployments/docker/migrations/002_connection_status.sql
autonomous: true

must_haves:
  truths:
    - "Discovered instances are persisted to the database"
    - "Instance listing returns data from database, not just cloud API"
    - "Connection status is tracked for each cloud account"
  artifacts:
    - path: "internal/store/postgres.go"
      provides: "InstanceStore with UpsertInstance, ListInstances, GetInstanceByID"
      contains: "func (s *InstanceStore) UpsertInstance"
    - path: "internal/discovery/discovery.go"
      provides: "Instance sync to database during discovery"
      contains: "store.UpsertInstance"
    - path: "internal/models/models.go"
      provides: "CloudAccount.ConnectionStatus field"
      contains: "ConnectionStatus"
  key_links:
    - from: "internal/discovery/discovery.go"
      to: "internal/store/postgres.go"
      via: "InstanceStore dependency"
      pattern: "store\\.UpsertInstance"
---

<objective>
Implement instance persistence and connection status tracking in the backend.

Purpose: Currently instances are fetched live from cloud APIs each request. This plan adds database persistence so instances can be queried efficiently and connection health is tracked for UI display.

Output: Working instance sync from discovery to database, connection status tracking for cloud accounts.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-multi-cloud-discovery/01-RESEARCH.md

@internal/store/postgres.go
@internal/discovery/discovery.go
@internal/models/models.go
@deployments/docker/migrations/001_base_schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add InstanceStore with UpsertInstance and ListInstances</name>
  <files>internal/store/postgres.go, internal/models/models.go</files>
  <action>
Add `InstanceStore` struct and methods to `postgres.go`:

1. Create `InstanceStore` struct wrapping `*Postgres`
2. Add `NewInstanceStore(db *Postgres) *InstanceStore`
3. Add `UpsertInstance(ctx context.Context, instance *models.Instance) error`:
   - Use SQL: `INSERT INTO instances (...) VALUES (...) ON CONFLICT (provider, provider_id) DO UPDATE SET name=EXCLUDED.name, status=EXCLUDED.status, tags=EXCLUDED.tags, hourly_cost_cents=EXCLUDED.hourly_cost_cents, updated_at=NOW() RETURNING id`
   - Handle JSONB tags with `json.Marshal()`
   - Set `cloud_account_id` from instance
4. Add `ListInstances(ctx context.Context) ([]models.Instance, error)`:
   - Query all instances from database
   - Parse tags JSONB back to `map[string]string`
   - Include cloud_account_id in query
5. Add `GetInstanceByProviderID(ctx context.Context, provider, providerID string) (*models.Instance, error)`

In `models.go`, ensure Instance model has CloudAccountID field properly tagged for database operations.

Follow existing CloudAccountStore pattern for consistency (raw SQL, context-based, error wrapping with fmt.Errorf).
  </action>
  <verify>
`go build ./...` compiles without errors
  </verify>
  <done>
InstanceStore is created with UpsertInstance, ListInstances, GetInstanceByProviderID methods that compile and follow existing store patterns.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add connection status tracking to CloudAccount</name>
  <files>internal/models/models.go, internal/store/postgres.go, deployments/docker/migrations/002_connection_status.sql</files>
  <action>
1. In `models.go`, add fields to CloudAccount:
   - `ConnectionStatus string` with json:"connection_status" db:"connection_status" (values: "connected", "syncing", "failed", "unknown")
   - `LastSyncAt *time.Time` with json:"last_sync_at" db:"last_sync_at"
   - `LastError *string` with json:"last_error,omitempty" db:"last_error"

2. Create migration file `002_connection_status.sql`:
   - `ALTER TABLE cloud_accounts ADD COLUMN connection_status VARCHAR(50) DEFAULT 'unknown';`
   - `ALTER TABLE cloud_accounts ADD COLUMN last_sync_at TIMESTAMPTZ;`
   - `ALTER TABLE cloud_accounts ADD COLUMN last_error TEXT;`

3. In `postgres.go`, add to CloudAccountStore:
   - `UpdateConnectionStatus(ctx context.Context, id string, status string, lastError *string) error`
   - Update ListCloudAccounts to include new columns in SELECT
   - Update GetCloudAccount to include new columns

Follow existing SQL patterns, use parameterized queries.
  </action>
  <verify>
`go build ./...` compiles without errors. Migration file exists with valid SQL.
  </verify>
  <done>
CloudAccount model has ConnectionStatus, LastSyncAt, LastError fields. CloudAccountStore has UpdateConnectionStatus method. Migration file created.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire discovery service to persist instances and update connection status</name>
  <files>internal/discovery/discovery.go, cmd/server/main.go</files>
  <action>
1. Modify `DiscoveryService` struct in `discovery.go`:
   - Add `instanceStore` field (interface or pointer to store)
   - Add `accountStore` field for connection status updates
   - Define minimal interface if needed to avoid circular imports

2. Update `NewDiscoveryService` signature to accept stores:
   - `func NewDiscoveryService(registry *provider.Registry, instanceStore InstanceStore, accountStore AccountStore, enabled bool, interval int, tags []string) *DiscoveryService`

3. Modify `Run(ctx context.Context) error`:
   - Before listing databases, update account status to "syncing" for all accounts
   - For each discovered instance, call `instanceStore.UpsertInstance(ctx, instance)`
   - On success, update account status to "connected" with LastSyncAt = now
   - On error, update account status to "failed" with LastError = error message
   - Log sync results: "Synced N instances to database"

4. Update `cmd/server/main.go`:
   - Create InstanceStore: `instanceStore := store.NewInstanceStore(db)`
   - Create AccountStore reference for status updates
   - Pass stores to NewDiscoveryService

5. Update `/api/v1/instances` endpoint to use `instanceStore.ListInstances()` instead of `discoveryService.ListAllDatabases()`:
   - This returns persisted data from DB, not live API calls
   - Keep discoveryService.ListAllDatabases for background sync

Handle the interface boundary cleanly - define store interfaces in discovery package to avoid import cycles.
  </action>
  <verify>
`go build ./...` compiles. Server starts without errors. After discovery runs, instances appear in database (check via `SELECT * FROM instances`).
  </verify>
  <done>
Discovery service syncs instances to database during Run(). Connection status is updated per-account. API returns instances from database.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `go build ./...` compiles without errors
2. Server starts and discovery runs on schedule
3. `curl http://localhost:8080/api/v1/instances` returns instances from database
4. Database shows instances in `instances` table after discovery
5. Cloud accounts have connection_status updated ("connected", "syncing", or "failed")
</verification>

<success_criteria>
- InstanceStore with UpsertInstance, ListInstances methods exists and works
- CloudAccount model has ConnectionStatus, LastSyncAt, LastError fields
- Discovery service persists instances to database during Run()
- Connection status is tracked per-account ("connected"/"syncing"/"failed")
- API returns instances from database, not live cloud API calls
- Migration file exists for connection status columns
</success_criteria>

<output>
After completion, create `.planning/phases/01-multi-cloud-discovery/01-01-SUMMARY.md`
</output>
