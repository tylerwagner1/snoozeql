---
phase: 02-manual-control-audit
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - cmd/server/main.go
  - web/src/lib/api.ts
autonomous: true

must_haves:
  truths:
    - "POST /api/v1/instances/bulk-stop accepts array of instance_ids and stops them"
    - "POST /api/v1/instances/bulk-start accepts array of instance_ids and starts them"
    - "Bulk operations create event records for each successful operation"
    - "Bulk operations return success/failed arrays for partial failure handling"
  artifacts:
    - path: "cmd/server/main.go"
      provides: "Bulk stop and start endpoints"
      contains: "r.Post(\"/instances/bulk-stop\""
    - path: "web/src/lib/api.ts"
      provides: "bulkStopInstances, bulkStartInstances functions"
      contains: "bulkStopInstances"
  key_links:
    - from: "cmd/server/main.go bulk-stop"
      to: "discoveryService.StopDatabase"
      via: "loop over instance IDs"
      pattern: "discoveryService\\.StopDatabase"
    - from: "cmd/server/main.go bulk-stop"
      to: "eventStore.CreateEvent"
      via: "audit logging after each stop"
      pattern: "eventStore\\.CreateEvent"
---

<objective>
Add bulk sleep/wake API endpoints with audit logging

Purpose: Enable multi-instance operations from the frontend with proper event logging
Output: POST /api/v1/instances/bulk-stop and bulk-start endpoints that process arrays of instances and log events
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-manual-control-audit/02-RESEARCH.md
@.planning/phases/02-manual-control-audit/02-01-SUMMARY.md

@cmd/server/main.go
@internal/store/postgres.go
@internal/discovery/discovery.go
@internal/models/models.go
@web/src/lib/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add bulk stop/start endpoints</name>
  <files>cmd/server/main.go</files>
  <action>
Add bulk operation endpoints after the existing single instance /stop and /start endpoints (around line 374).

First, add these type definitions near the top of main() or as package-level types:
```go
// BulkOperationRequest represents a request to start/stop multiple instances
type BulkOperationRequest struct {
    InstanceIDs []string `json:"instance_ids"`
}

// BulkOperationResponse represents the result of a bulk operation
type BulkOperationResponse struct {
    Success []string         `json:"success"`
    Failed  []OperationError `json:"failed"`
}

// OperationError represents a failed operation
type OperationError struct {
    InstanceID string `json:"instance_id"`
    Error      string `json:"error"`
}
```

Then add the endpoints:
```go
// Bulk stop instances
r.Post("/instances/bulk-stop", func(w http.ResponseWriter, r *http.Request) {
    var req BulkOperationRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusBadRequest)
        w.Write([]byte(`{"error":"Invalid request body"}`))
        return
    }

    if len(req.InstanceIDs) == 0 {
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusBadRequest)
        w.Write([]byte(`{"error":"No instance IDs provided"}`))
        return
    }

    ctx := r.Context()
    var success []string
    var failed []OperationError

    for _, instanceID := range req.InstanceIDs {
        // Get instance from database to find provider and current status
        instance, err := instanceStore.GetInstanceByProviderID(ctx, "", instanceID)
        if err != nil {
            // Try by ID directly
            instances, listErr := instanceStore.ListInstances(ctx)
            if listErr != nil {
                failed = append(failed, OperationError{InstanceID: instanceID, Error: "Instance not found"})
                continue
            }
            var found *models.Instance
            for i := range instances {
                if instances[i].ID == instanceID {
                    found = &instances[i]
                    break
                }
            }
            if found == nil {
                failed = append(failed, OperationError{InstanceID: instanceID, Error: "Instance not found"})
                continue
            }
            instance = found
        }

        // Check if instance is in a stoppable state
        if instance.Status != "available" && instance.Status != "running" {
            failed = append(failed, OperationError{
                InstanceID: instanceID,
                Error:      fmt.Sprintf("Instance not in stoppable state (current: %s)", instance.Status),
            })
            continue
        }

        // Stop the instance using provider_id (the actual cloud resource name)
        if err := discoveryService.StopDatabase(ctx, instance.Provider, instance.ProviderID); err != nil {
            failed = append(failed, OperationError{InstanceID: instanceID, Error: err.Error()})
            continue
        }

        // Log the event
        event := &models.Event{
            InstanceID:     instance.ID,
            EventType:      "sleep",
            TriggeredBy:    "manual",
            PreviousStatus: instance.Status,
            NewStatus:      "stopping",
        }
        if err := eventStore.CreateEvent(ctx, event); err != nil {
            log.Printf("Warning: Failed to log event for instance %s: %v", instanceID, err)
        }

        success = append(success, instanceID)
    }

    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusOK)
    json.NewEncoder(w).Encode(BulkOperationResponse{Success: success, Failed: failed})
})

// Bulk start instances
r.Post("/instances/bulk-start", func(w http.ResponseWriter, r *http.Request) {
    var req BulkOperationRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusBadRequest)
        w.Write([]byte(`{"error":"Invalid request body"}`))
        return
    }

    if len(req.InstanceIDs) == 0 {
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusBadRequest)
        w.Write([]byte(`{"error":"No instance IDs provided"}`))
        return
    }

    ctx := r.Context()
    var success []string
    var failed []OperationError

    for _, instanceID := range req.InstanceIDs {
        // Get instance from database
        instance, err := instanceStore.GetInstanceByProviderID(ctx, "", instanceID)
        if err != nil {
            instances, listErr := instanceStore.ListInstances(ctx)
            if listErr != nil {
                failed = append(failed, OperationError{InstanceID: instanceID, Error: "Instance not found"})
                continue
            }
            var found *models.Instance
            for i := range instances {
                if instances[i].ID == instanceID {
                    found = &instances[i]
                    break
                }
            }
            if found == nil {
                failed = append(failed, OperationError{InstanceID: instanceID, Error: "Instance not found"})
                continue
            }
            instance = found
        }

        // Check if instance is in a startable state
        if instance.Status != "stopped" {
            failed = append(failed, OperationError{
                InstanceID: instanceID,
                Error:      fmt.Sprintf("Instance not in startable state (current: %s)", instance.Status),
            })
            continue
        }

        // Start the instance
        if err := discoveryService.StartDatabase(ctx, instance.Provider, instance.ProviderID); err != nil {
            failed = append(failed, OperationError{InstanceID: instanceID, Error: err.Error()})
            continue
        }

        // Log the event
        event := &models.Event{
            InstanceID:     instance.ID,
            EventType:      "wake",
            TriggeredBy:    "manual",
            PreviousStatus: instance.Status,
            NewStatus:      "starting",
        }
        if err := eventStore.CreateEvent(ctx, event); err != nil {
            log.Printf("Warning: Failed to log event for instance %s: %v", instanceID, err)
        }

        success = append(success, instanceID)
    }

    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusOK)
    json.NewEncoder(w).Encode(BulkOperationResponse{Success: success, Failed: failed})
})
```

Note: 
- Uses instance.ProviderID for cloud API calls (the actual RDS/Cloud SQL identifier)
- Uses instance.ID (UUID) for event logging 
- Checks instance state before attempting operation
- Continues processing other instances if one fails (partial success)
  </action>
  <verify>`go build ./...` succeeds. Test with curl: `curl -X POST -H "Authorization: Bearer dev-key" -H "Content-Type: application/json" -d '{"instance_ids":[]}' http://localhost:8080/api/v1/instances/bulk-stop` returns error about no IDs</verify>
  <done>POST /api/v1/instances/bulk-stop and bulk-start endpoints exist, process arrays, return success/failed arrays</done>
</task>

<task type="auto">
  <name>Task 2: Add bulk operations to frontend API client</name>
  <files>web/src/lib/api.ts</files>
  <action>
1. Add BulkOperationResponse interface after the Event interface:
```typescript
export interface BulkOperationResponse {
  success: string[]
  failed: Array<{
    instance_id: string
    error: string
  }>
}
```

2. Add bulk operation functions to the api object (after stopInstance):
```typescript
// Bulk operations
bulkStopInstances: (instanceIds: string[]) => 
  api.post<BulkOperationResponse>('/instances/bulk-stop', { instance_ids: instanceIds }),
bulkStartInstances: (instanceIds: string[]) => 
  api.post<BulkOperationResponse>('/instances/bulk-start', { instance_ids: instanceIds }),
```
  </action>
  <verify>`cd web && npm run build` compiles without TypeScript errors</verify>
  <done>bulkStopInstances and bulkStartInstances functions exist in api client</done>
</task>

</tasks>

<verification>
1. Backend compiles: `go build ./...`
2. Bulk-stop endpoint exists: `curl -X POST -H "Authorization: Bearer dev-key" -H "Content-Type: application/json" -d '{"instance_ids":[]}' http://localhost:8080/api/v1/instances/bulk-stop`
3. Frontend compiles: `cd web && npm run build`
</verification>

<success_criteria>
- POST /api/v1/instances/bulk-stop accepts instance_ids array, returns success/failed arrays
- POST /api/v1/instances/bulk-start accepts instance_ids array, returns success/failed arrays
- Both endpoints create event records for successful operations (event_type: "sleep" or "wake")
- Frontend has bulkStopInstances and bulkStartInstances functions
- All code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-manual-control-audit/02-03-SUMMARY.md`
</output>
