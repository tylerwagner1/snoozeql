---
phase: 02-manual-control-audit
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/store/postgres.go
  - cmd/server/main.go
  - web/src/lib/api.ts
autonomous: true

must_haves:
  truths:
    - "EventStore can create event records in database"
    - "EventStore can list events with pagination"
    - "Events API returns events as JSON"
  artifacts:
    - path: "internal/store/postgres.go"
      provides: "EventStore struct with CreateEvent, ListEvents methods"
      contains: "type EventStore struct"
    - path: "cmd/server/main.go"
      provides: "GET /api/v1/events endpoint"
      contains: "r.Get(\"/events\""
    - path: "web/src/lib/api.ts"
      provides: "Event interface and getEvents function"
      contains: "getEvents"
  key_links:
    - from: "cmd/server/main.go"
      to: "internal/store/postgres.go"
      via: "eventStore.ListEvents call"
      pattern: "eventStore\\.ListEvents"
---

<objective>
Create EventStore for audit logging and Events API endpoint

Purpose: Foundation for all audit logging - all sleep/wake operations will be recorded to this store
Output: Working EventStore with CreateEvent/ListEvents methods, GET /api/v1/events endpoint returning events
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-manual-control-audit/02-RESEARCH.md

@internal/store/postgres.go
@internal/models/models.go
@cmd/server/main.go
@web/src/lib/api.ts
@deployments/docker/migrations/001_base_schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add EventStore to postgres.go</name>
  <files>internal/store/postgres.go</files>
  <action>
Add EventStore struct following the existing InstanceStore pattern:

```go
// EventStore provides event CRUD operations
type EventStore struct {
    db *Postgres
}

// NewEventStore creates a new event store
func NewEventStore(db *Postgres) *EventStore {
    return &EventStore{db: db}
}

// CreateEvent inserts an event into the database
func (s *EventStore) CreateEvent(ctx context.Context, event *models.Event) error {
    query := `
        INSERT INTO events (instance_id, event_type, triggered_by, previous_status, new_status, metadata)
        VALUES ($1, $2, $3, $4, $5, $6)
        RETURNING id, created_at`
    return s.db.QueryRowContext(ctx, query,
        event.InstanceID, event.EventType, event.TriggeredBy,
        event.PreviousStatus, event.NewStatus, event.Metadata,
    ).Scan(&event.ID, &event.CreatedAt)
}

// ListEvents returns events with pagination (most recent first)
func (s *EventStore) ListEvents(ctx context.Context, limit int, offset int) ([]models.Event, error) {
    if limit <= 0 {
        limit = 50
    }
    query := `
        SELECT id, instance_id, event_type, triggered_by, previous_status, new_status, metadata, created_at
        FROM events ORDER BY created_at DESC LIMIT $1 OFFSET $2`
    rows, err := s.db.Query(ctx, query, limit, offset)
    if err != nil {
        return nil, fmt.Errorf("failed to query events: %w", err)
    }
    defer rows.Close()

    var events []models.Event
    for rows.Next() {
        var e models.Event
        err := rows.Scan(&e.ID, &e.InstanceID, &e.EventType, &e.TriggeredBy,
            &e.PreviousStatus, &e.NewStatus, &e.Metadata, &e.CreatedAt)
        if err != nil {
            return nil, fmt.Errorf("failed to scan event: %w", err)
        }
        events = append(events, e)
    }
    if err := rows.Err(); err != nil {
        return nil, fmt.Errorf("rows error: %w", err)
    }
    return events, nil
}

// ListEventsByInstance returns events for a specific instance
func (s *EventStore) ListEventsByInstance(ctx context.Context, instanceID string) ([]models.Event, error) {
    query := `
        SELECT id, instance_id, event_type, triggered_by, previous_status, new_status, metadata, created_at
        FROM events WHERE instance_id = $1 ORDER BY created_at DESC`
    rows, err := s.db.Query(ctx, query, instanceID)
    if err != nil {
        return nil, fmt.Errorf("failed to query events: %w", err)
    }
    defer rows.Close()

    var events []models.Event
    for rows.Next() {
        var e models.Event
        err := rows.Scan(&e.ID, &e.InstanceID, &e.EventType, &e.TriggeredBy,
            &e.PreviousStatus, &e.NewStatus, &e.Metadata, &e.CreatedAt)
        if err != nil {
            return nil, fmt.Errorf("failed to scan event: %w", err)
        }
        events = append(events, e)
    }
    return events, rows.Err()
}
```

Note: The events table already exists in 001_base_schema.sql with correct columns (id, instance_id, event_type, triggered_by, previous_status, new_status, metadata, created_at).
  </action>
  <verify>`go build ./...` succeeds without errors</verify>
  <done>EventStore with CreateEvent, ListEvents, ListEventsByInstance methods exists and compiles</done>
</task>

<task type="auto">
  <name>Task 2: Add events API endpoint and wire EventStore</name>
  <files>cmd/server/main.go</files>
  <action>
1. Add global eventStore variable near other globals:
```go
var (
    discoveryService *discovery.DiscoveryService
    instanceStore    *store.InstanceStore
    accountStore     *store.CloudAccountStore
    eventStore       *store.EventStore  // Add this
)
```

2. Initialize eventStore after other store instances (around line 158):
```go
// Create store instances for discovery
instanceStore = store.NewInstanceStore(db)
accountStore = store.NewCloudAccountStore(db)
eventStore = store.NewEventStore(db)  // Add this
```

3. Add GET /events endpoint inside the /api/v1 route group (after /recommendations section, around line 410):
```go
// Events/Audit Log
r.Get("/events", func(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    
    // Parse optional pagination params
    limit := 50
    offset := 0
    if l := r.URL.Query().Get("limit"); l != "" {
        if parsed, err := strconv.Atoi(l); err == nil && parsed > 0 && parsed <= 100 {
            limit = parsed
        }
    }
    if o := r.URL.Query().Get("offset"); o != "" {
        if parsed, err := strconv.Atoi(o); err == nil && parsed >= 0 {
            offset = parsed
        }
    }
    
    events, err := eventStore.ListEvents(ctx, limit, offset)
    if err != nil {
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusInternalServerError)
        log.Printf("ERROR listing events: %v", err)
        w.Write([]byte(`{"error":"Failed to list events"}`))
        return
    }
    
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusOK)
    json.NewEncoder(w).Encode(events)
})
```

4. Add strconv import if not already present:
```go
import (
    ...
    "strconv"
    ...
)
```
  </action>
  <verify>`go build ./...` succeeds. Start server and `curl -H "Authorization: Bearer dev-key" http://localhost:8080/api/v1/events` returns `[]` (empty array, no events yet)</verify>
  <done>GET /api/v1/events endpoint exists, returns events array (empty initially), accepts limit/offset query params</done>
</task>

<task type="auto">
  <name>Task 3: Add Event interface and getEvents to frontend API client</name>
  <files>web/src/lib/api.ts</files>
  <action>
1. Add Event interface after the existing interfaces (after CloudAccount interface, around line 59):
```typescript
export interface Event {
  id: string
  instance_id: string
  event_type: string
  triggered_by: string
  previous_status: string
  new_status: string
  metadata?: Record<string, unknown>
  created_at: string
}
```

2. Add getEvents function to the api object (after getCloudAccounts, around line 147):
```typescript
// Events/Audit Log
getEvents: (limit?: number, offset?: number) => {
  const params = new URLSearchParams()
  if (limit) params.set('limit', limit.toString())
  if (offset) params.set('offset', offset.toString())
  const query = params.toString()
  return api.get<Event[]>(`/events${query ? `?${query}` : ''}`)
},
getEventsByInstance: (instanceId: string) => 
  api.get<Event[]>(`/instances/${instanceId}/events`),
```
  </action>
  <verify>Run `cd web && npm run build` - should compile without TypeScript errors</verify>
  <done>Event interface exists, api.getEvents() function available for fetching events</done>
</task>

</tasks>

<verification>
1. Backend compiles: `go build ./...`
2. Events endpoint works: Start server, `curl -H "Authorization: Bearer dev-key" http://localhost:8080/api/v1/events` returns `[]`
3. Frontend compiles: `cd web && npm run build`
</verification>

<success_criteria>
- EventStore struct exists with CreateEvent, ListEvents, ListEventsByInstance methods
- GET /api/v1/events endpoint returns events array (empty initially)
- Event interface and getEvents function exist in frontend API client
- All code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-manual-control-audit/02-01-SUMMARY.md`
</output>
