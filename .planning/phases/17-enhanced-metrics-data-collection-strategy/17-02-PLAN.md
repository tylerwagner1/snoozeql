---
phase: 17-enhanced-metrics-data-collection-strategy
plan: 02
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - internal/metrics/store.go
  - internal/metrics/collector.go
  - cmd/server/main.go
autonomous: true

must_haves:
  truths:
    - "Gap detection runs on server startup before continuous collection"
    - "Gaps longer than 15 minutes are detected and filled with interpolated data"
    - "Interpolated entries use SampleCount=0 to indicate synthetic data"
  artifacts:
    - path: "internal/metrics/store.go"
      provides: "GetLatestMetricTimes and GetMetricsAtTime methods"
      exports: ["GetLatestMetricTimes", "GetMetricsAtTime"]
    - path: "internal/metrics/collector.go"
      provides: "DetectAndFillGaps and fillGap methods"
      exports: ["DetectAndFillGaps"]
    - path: "cmd/server/main.go"
      provides: "Gap detection call before RunContinuous"
      contains: "DetectAndFillGaps"
  key_links:
    - from: "cmd/server/main.go"
      to: "collector.DetectAndFillGaps"
      via: "startup call"
      pattern: "metricsCollector\\.DetectAndFillGaps"
    - from: "collector.go"
      to: "store.go"
      via: "GetLatestMetricTimes query"
      pattern: "metricsStore\\.GetLatestMetricTimes"
---

<objective>
Add gap detection on server startup with linear interpolation to fill missing metric intervals.

Purpose: Maintain continuous timeline for metrics visualization even after server downtime
Output: Gaps detected and filled with interpolated entries (SampleCount=0) on startup
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-enhanced-metrics-data-collection-strategy/17-RESEARCH.md
@.planning/phases/17-enhanced-metrics-data-collection-strategy/17-01-SUMMARY.md

@internal/metrics/store.go
@internal/metrics/collector.go
@cmd/server/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add gap detection helper methods to store.go</name>
  <files>internal/metrics/store.go</files>
  <action>
Add two new methods to MetricsStore:

1. `GetLatestMetricTimes` - batch query for all instances:
```go
// GetLatestMetricTimes returns the most recent metric timestamp for each instance
// Returns map[instanceID]time.Time
func (s *MetricsStore) GetLatestMetricTimes(ctx context.Context) (map[string]time.Time, error) {
    query := `
        SELECT instance_id, MAX(hour) as latest
        FROM metrics_hourly
        GROUP BY instance_id`
    
    rows, err := s.db.Query(ctx, query)
    // ... iterate and build map
}
```
This batch approach avoids N queries for N instances (Pitfall 5 from RESEARCH.md).

2. `GetMetricsAtTime` - get all metric values at a specific timestamp:
```go
// GetMetricsAtTime returns metrics for an instance at a specific timestamp
// Used to get boundary values for interpolation
func (s *MetricsStore) GetMetricsAtTime(ctx context.Context, instanceID string, timestamp time.Time) ([]models.HourlyMetric, error) {
    query := `
        SELECT id, instance_id, metric_name, hour, avg_value, max_value, min_value, sample_count, created_at, updated_at
        FROM metrics_hourly
        WHERE instance_id = $1 AND hour = $2`
    // ... return all metrics at that timestamp
}
```
  </action>
  <verify>
Run `go build ./...` - no compilation errors
Grep for "GetLatestMetricTimes" and "GetMetricsAtTime" in store.go
  </verify>
  <done>
GetLatestMetricTimes returns map[instanceID]time.Time efficiently in one query
GetMetricsAtTime returns metrics at specific timestamp for interpolation boundaries
  </done>
</task>

<task type="auto">
  <name>Task 2: Add gap detection and interpolation to collector.go</name>
  <files>internal/metrics/collector.go</files>
  <action>
Add three new methods to MetricsCollector:

1. `DetectAndFillGaps` - main entry point called on startup:
```go
// DetectAndFillGaps checks for missing metric intervals and fills with interpolated data
// Called once on server startup before continuous collection begins
func (c *MetricsCollector) DetectAndFillGaps(ctx context.Context) error {
    log.Println("Checking for metric gaps...")
    
    instances, err := c.instanceStore.ListInstances(ctx)
    latestTimes, err := c.metricsStore.GetLatestMetricTimes(ctx)
    
    for _, instance := range instances {
        if instance.Provider != "aws" {
            continue
        }
        
        lastTime, exists := latestTimes[instance.ID]
        if !exists {
            // No previous data, skip gap detection
            continue
        }
        
        gapStart := lastTime.Add(MetricPeriod)
        gapEnd := time.Now().UTC().Truncate(MetricPeriod)
        
        gapDuration := gapEnd.Sub(gapStart)
        if gapDuration > 15*time.Minute {
            log.Printf("Gap detected for %s: %s to %s (%v)", 
                instance.Name, gapStart.Format(time.RFC3339), gapEnd.Format(time.RFC3339), gapDuration)
            if err := c.fillGap(ctx, instance, gapStart, gapEnd, lastTime); err != nil {
                log.Printf("Failed to fill gap for %s: %v", instance.Name, err)
            }
        }
    }
    
    log.Println("Gap detection complete")
    return nil
}
```

2. `fillGap` - fills a detected gap with interpolated values:
```go
func (c *MetricsCollector) fillGap(ctx context.Context, instance models.Instance, gapStart, gapEnd, lastDataTime time.Time) error {
    // Get boundary values
    startMetrics, _ := c.metricsStore.GetMetricsAtTime(ctx, instance.ID, lastDataTime)
    // For end boundary, we don't have data yet - use start values (flat interpolation initially)
    
    intervals := int(gapEnd.Sub(gapStart) / MetricPeriod)
    
    // Cap at 7 days worth (per RESEARCH.md - retention limit)
    maxIntervals := 7 * 24 * 12 // 7 days * 24 hours * 12 intervals/hour
    if intervals > maxIntervals {
        intervals = maxIntervals
        gapStart = gapEnd.Add(-time.Duration(maxIntervals) * MetricPeriod)
    }
    
    for i := 0; i < intervals; i++ {
        timestamp := gapStart.Add(time.Duration(i) * MetricPeriod)
        
        for _, metricName := range []string{
            models.MetricCPUUtilization,
            models.MetricDatabaseConnections,
            models.MetricFreeableMemory,
        } {
            startVal := getMetricValueFromSlice(startMetrics, metricName)
            
            // For connections: use last-known value (discrete)
            // For CPU/Memory: linear interpolation (but with only start boundary, use flat)
            interpolated := startVal
            
            m := &models.HourlyMetric{
                InstanceID:  instance.ID,
                MetricName:  metricName,
                Hour:        timestamp,
                AvgValue:    interpolated,
                MaxValue:    interpolated,
                MinValue:    interpolated,
                SampleCount: 0, // 0 indicates interpolated data
            }
            c.metricsStore.UpsertHourlyMetric(ctx, m)
        }
    }
    
    log.Printf("Filled %d intervals for %s", intervals, instance.Name)
    return nil
}
```

3. `getMetricValueFromSlice` - helper to extract value:
```go
func getMetricValueFromSlice(metrics []models.HourlyMetric, name string) float64 {
    for _, m := range metrics {
        if m.MetricName == name {
            return m.AvgValue
        }
    }
    return 0 // Default to 0 if not found
}
```

Import MetricPeriod from store package (or use local constant `5 * time.Minute`).
  </action>
  <verify>
Run `go build ./...` - no compilation errors
Grep for "DetectAndFillGaps" and "fillGap" in collector.go
  </verify>
  <done>
DetectAndFillGaps detects gaps > 15 minutes for all instances
fillGap creates interpolated entries with SampleCount=0
Gap filling capped at 7 days (retention limit)
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire gap detection into server startup</name>
  <files>cmd/server/main.go</files>
  <action>
Update main.go to call gap detection before starting continuous collection:

Find the section (around line 213-215):
```go
// Start metrics collection in background
go metricsCollector.RunContinuous(ctx)
log.Printf("✓ Started metrics collector (15-minute interval)")
```

Change to:
```go
// Detect and fill metric gaps from downtime before starting collection
if err := metricsCollector.DetectAndFillGaps(ctx); err != nil {
    log.Printf("Warning: Gap detection failed: %v", err)
}

// Start metrics collection in background
go metricsCollector.RunContinuous(ctx)
log.Printf("✓ Started metrics collector (15-minute interval, 5-minute granularity)")
```

Note: DetectAndFillGaps runs synchronously at startup (blocking) because:
1. It should complete before continuous collection begins
2. It's a one-time operation, not continuous
3. Startup can wait a few seconds for gap detection
  </action>
  <verify>
Run `go build ./...` - no compilation errors
Grep for "DetectAndFillGaps" in main.go
Start server and check logs for "Checking for metric gaps..." and "Gap detection complete"
  </verify>
  <done>
Gap detection runs at server startup before continuous collection
Log output shows gap detection status
Gaps filled with interpolated entries when server was down
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `go build ./...` passes with no errors
2. `grep -r "DetectAndFillGaps" internal/metrics/ cmd/` shows method and call
3. `grep -r "GetLatestMetricTimes" internal/metrics/` shows batch query method
4. Server startup logs show "Checking for metric gaps..." message

Manual verification (for VERIFICATION.md):
- Stop server, wait 30+ minutes, restart
- Check logs for gap detection messages
- Query metrics_hourly for entries with sample_count=0 (interpolated)
- Verify timestamp continuity in metrics data
</verification>

<success_criteria>
- GetLatestMetricTimes batch query returns map[instanceID]time.Time efficiently
- GetMetricsAtTime returns metrics at specific timestamp for boundaries
- DetectAndFillGaps runs on startup and detects gaps > 15 minutes
- fillGap creates interpolated entries with SampleCount=0
- Gap filling capped at 7 days to match retention policy
- Server startup calls DetectAndFillGaps before RunContinuous
</success_criteria>

<output>
After completion, create `.planning/phases/17-enhanced-metrics-data-collection-strategy/17-02-SUMMARY.md`
</output>
