---
phase: 07-core-savings-calculation-api
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - internal/savings/event_decorator.go
  - cmd/server/main.go
autonomous: true

must_haves:
  truths:
    - "Savings are automatically calculated when a start/wake event occurs"
    - "Hourly rate is captured at stop event time in event metadata (AUD-02)"
    - "All savings calculations are logged with instance ID, date, stopped minutes, and rate (AUD-01)"
    - "Existing event creation flow continues to work unchanged"
  artifacts:
    - path: "internal/savings/event_decorator.go"
      provides: "EventStoreWithSavings decorator wrapping EventStore"
      exports: ["NewEventStoreWithSavings", "CreateEvent"]
    - path: "cmd/server/main.go"
      provides: "Wiring of decorated EventStore into discovery service"
      contains: "NewEventStoreWithSavings"
  key_links:
    - from: "internal/savings/event_decorator.go"
      to: "internal/store/postgres.go"
      via: "wraps EventStore"
      pattern: "EventStore"
    - from: "internal/savings/event_decorator.go"
      to: "internal/savings/calculator.go"
      via: "uses SavingsCalculator"
      pattern: "SavingsCalculator"
    - from: "internal/savings/event_decorator.go"
      to: "internal/store/savings_store.go"
      via: "persists calculated savings"
      pattern: "SavingsStore"
    - from: "cmd/server/main.go"
      to: "internal/savings/event_decorator.go"
      via: "creates decorated EventStore"
      pattern: "NewEventStoreWithSavings"
---

<objective>
Create the EventStoreWithSavings decorator that automatically calculates and persists savings when instances are started, and wire it into the application.

Purpose: Implements the push model where savings are calculated immediately when events occur, rather than on every dashboard load. This satisfies SAV-01 (calculate savings from stop/start events) and AUD-01/AUD-02 (logging requirements).

Output:
- EventStoreWithSavings decorator that intercepts CreateEvent calls
- When start/wake event detected, finds previous stop event and calculates savings
- Captures hourly_rate_cents in stop event metadata
- Integration into main.go replacing direct EventStore usage
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/SUMMARY.md
@.planning/phases/07-core-savings-calculation-api/07-01-SUMMARY.md
@internal/store/postgres.go
@internal/models/models.go
@cmd/server/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement EventStoreWithSavings decorator</name>
  <files>internal/savings/event_decorator.go</files>
  <action>
Create event_decorator.go in internal/savings/:

1. Define interface that matches existing EventStore methods:
   ```go
   type EventCreator interface {
       CreateEvent(ctx context.Context, event *models.Event) error
       ListEventsByInstance(ctx context.Context, instanceID string) ([]models.Event, error)
   }
   ```

2. EventStoreWithSavings struct:
   ```go
   type EventStoreWithSavings struct {
       wrapped       EventCreator
       calculator    *SavingsCalculator
       savingsStore  SavingsStorer  // interface for store
       instanceStore InstanceGetter // interface to get hourly cost
   }
   ```

3. Define minimal interfaces for dependencies:
   ```go
   type SavingsStorer interface {
       UpsertDailySaving(ctx context.Context, saving *models.Saving) error
   }
   
   type InstanceGetter interface {
       GetInstanceByID(ctx context.Context, id string) (*models.Instance, error)
   }
   ```

4. NewEventStoreWithSavings constructor

5. CreateEvent method:
   - Always call wrapped.CreateEvent first (preserve existing behavior)
   - If event is "sleep" or "stop" type:
     - Get instance to capture hourly_rate_cents
     - Store hourly_rate_cents in event metadata as JSON
   - If event is "wake" or "start" type:
     - Find most recent stop/sleep event for this instance
     - Extract hourly_rate_cents from stop event metadata (or fallback to instance.HourlyCostCents)
     - Use calculator.SplitByDay to get per-day savings
     - For each day, call savingsStore.UpsertDailySaving
     - Log calculation details (instance_id, date, stopped_minutes, rate) - satisfies AUD-01
   - Return original error if wrapped.CreateEvent failed

6. Passthrough methods for ListEvents, ListEventsByInstance (delegate to wrapped)

Handle edge cases:
- No previous stop event found (instance was never stopped by SnoozeQL)
- Stop event has no hourly_rate_cents in metadata (migration from old events)
- Multiple consecutive stops without starts (take earliest stop)
  </action>
  <verify>
- File compiles: `go build ./internal/savings/...`
- Decorator wraps EventStore: `grep "wrapped.*EventCreator" internal/savings/event_decorator.go`
- Handles both stop and start events: `grep -E "sleep|stop|wake|start" internal/savings/event_decorator.go`
  </verify>
  <done>
- EventStoreWithSavings struct with all dependencies
- CreateEvent intercepts stop events to capture hourly_rate_cents in metadata
- CreateEvent intercepts start events to calculate and persist savings
- Per-day savings split and persisted via SavingsStore
- Existing EventStore behavior preserved (decorator pattern)
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire decorated EventStore into main.go</name>
  <files>cmd/server/main.go</files>
  <action>
Update main.go to use EventStoreWithSavings:

1. Add import for savings package:
   ```go
   "snoozeql/internal/savings"
   ```

2. After creating stores (around line 180-190), create SavingsStore:
   ```go
   savingsStore := store.NewSavingsStore(db)
   ```

3. Create SavingsCalculator:
   ```go
   savingsCalculator := savings.NewSavingsCalculator()
   ```

4. Create decorated EventStore:
   ```go
   decoratedEventStore := savings.NewEventStoreWithSavings(
       eventStore,
       savingsCalculator,
       savingsStore,
       instanceStore,
   )
   ```

5. Update DiscoveryService creation to use decoratedEventStore:
   - Find the line: `discoveryService = discovery.NewDiscoveryService(..., eventStore, ...)`
   - Change `eventStore` to `decoratedEventStore`

6. Keep original eventStore for direct event queries (like ListEvents) that don't need savings decoration

The decorator only affects event creation - existing event reading paths remain unchanged.
  </action>
  <verify>
- File compiles: `go build ./cmd/server/...`
- Savings package imported: `grep "snoozeql/internal/savings" cmd/server/main.go`
- Decorated EventStore created: `grep "NewEventStoreWithSavings" cmd/server/main.go`
- DiscoveryService uses decorated store: Check the NewDiscoveryService call uses decoratedEventStore
  </verify>
  <done>
- imports internal/savings package
- Creates SavingsStore, SavingsCalculator, and EventStoreWithSavings
- DiscoveryService uses decorated EventStore for automatic savings calculation
- Bulk operations that create events will now automatically trigger savings calculation
  </done>
</task>

</tasks>

<verification>
1. Full application compiles: `go build ./...`
2. Server starts without errors: `go run ./cmd/server/...` (brief startup test)
3. Decorator pattern correctly preserves existing behavior
4. Stop events capture hourly_rate_cents in metadata
5. Start events trigger savings calculation
</verification>

<success_criteria>
- EventStoreWithSavings decorator implemented with all required methods
- main.go wires decorated EventStore into DiscoveryService
- Application compiles and starts
- Stop events automatically capture hourly rate
- Start events automatically calculate and persist savings
- AUD-01: Calculations logged with instance_id, date, stopped_minutes, rate
- AUD-02: Hourly rate captured at stop event time
</success_criteria>

<output>
After completion, create `.planning/phases/07-core-savings-calculation-api/07-02-SUMMARY.md`
</output>
