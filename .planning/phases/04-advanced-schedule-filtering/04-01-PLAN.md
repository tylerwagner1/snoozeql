---
phase: 04-advanced-schedule-filtering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/scheduler/matcher.go
  - internal/api/handlers/schedules.go
  - web/src/lib/filterUtils.ts
autonomous: true

must_haves:
  truths:
    - "Backend can match instances against selectors with AND/OR operators"
    - "Filter preview API endpoint returns matching instances"
    - "Client-side filter utilities match JavaScript and Go behavior"
  artifacts:
    - path: "internal/scheduler/matcher.go"
      provides: "Instance matching logic for selectors"
      exports: ["MatchInstance", "MatchSelector"]
    - path: "web/src/lib/filterUtils.ts"
      provides: "Client-side instance filtering utilities"
      exports: ["matchInstance", "matchSelector", "matchField", "validateRegex"]
  key_links:
    - from: "internal/api/handlers/schedules.go"
      to: "internal/scheduler/matcher.go"
      via: "import and MatchInstance call"
      pattern: "scheduler\\.MatchInstance"
    - from: "web/src/lib/filterUtils.ts"
      to: "Instance type"
      via: "import from api.ts"
      pattern: "import.*Instance.*from.*api"
---

<objective>
Implement backend matcher and filter utilities for selector-based instance matching.

Purpose: Create the core matching logic that powers filter preview and schedule execution. Both backend (Go) and frontend (JavaScript) need consistent matching behavior.

Output: Backend matcher.go with MatchInstance function, extended schedules API with preview endpoint, and frontend filterUtils.ts for client-side preview.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-advanced-schedule-filtering/04-CONTEXT.md
@.planning/phases/04-advanced-schedule-filtering/04-RESEARCH.md
@internal/models/models.go
@internal/api/handlers/schedules.go
@web/src/lib/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create backend instance matcher</name>
  <files>internal/scheduler/matcher.go</files>
  <action>
Create `internal/scheduler/matcher.go` with instance matching logic:

```go
package scheduler

import (
    "regexp"
    "strings"
    
    "snoozeql/internal/models"
)

// MatchInstance checks if an instance matches a set of selectors.
// operator is "and" (all selectors must match) or "or" (any selector must match).
// Empty selectors returns false (require explicit selection).
func MatchInstance(instance *models.Instance, selectors []models.Selector, operator string) bool {
    if len(selectors) == 0 {
        return false // Require at least one selector
    }
    
    for _, sel := range selectors {
        matches := MatchSelector(instance, &sel)
        if operator == "or" && matches {
            return true
        }
        if operator == "and" && !matches {
            return false
        }
    }
    
    return operator == "and"
}

// MatchSelector checks if an instance matches a single selector.
// All non-nil fields in the selector must match (AND within selector).
func MatchSelector(instance *models.Instance, sel *models.Selector) bool {
    // Check name matcher
    if sel.Name != nil {
        if !matchMatcher(instance.Name, sel.Name) {
            return false
        }
    }
    
    // Check provider (exact match: "aws" or "gcp")
    if sel.Provider != nil {
        instanceProvider := "gcp"
        if strings.HasPrefix(instance.Provider, "aws") {
            instanceProvider = "aws"
        }
        if *sel.Provider != instanceProvider {
            return false
        }
    }
    
    // Check region matcher
    if sel.Region != nil {
        if !matchMatcher(instance.Region, sel.Region) {
            return false
        }
    }
    
    // Check engine matcher
    if sel.Engine != nil {
        if !matchMatcher(instance.Engine, sel.Engine) {
            return false
        }
    }
    
    // Check tags (all specified tags must match)
    if sel.Tags != nil {
        for tagKey, matcher := range sel.Tags {
            tagValue, ok := instance.Tags[tagKey]
            if !ok {
                return false // Tag key doesn't exist
            }
            if !matchMatcher(tagValue, matcher) {
                return false
            }
        }
    }
    
    return true
}

// matchMatcher applies a Matcher to a string value
func matchMatcher(value string, matcher *models.Matcher) bool {
    if matcher == nil {
        return true
    }
    
    switch matcher.Type {
    case models.MatchExact:
        return value == matcher.Pattern
    case models.MatchContains:
        return strings.Contains(value, matcher.Pattern)
    case models.MatchPrefix:
        return strings.HasPrefix(value, matcher.Pattern)
    case models.MatchSuffix:
        return strings.HasSuffix(value, matcher.Pattern)
    case models.MatchRegex:
        re, err := regexp.Compile(matcher.Pattern)
        if err != nil {
            return false // Invalid regex doesn't match
        }
        return re.MatchString(value)
    default:
        return false
    }
}

// ValidateSelectors checks if all selectors have valid patterns.
// Returns error message if invalid, empty string if valid.
func ValidateSelectors(selectors []models.Selector) string {
    for i, sel := range selectors {
        if sel.Name != nil && sel.Name.Type == models.MatchRegex {
            if _, err := regexp.Compile(sel.Name.Pattern); err != nil {
                return "Invalid regex in selector " + string(rune(i+1)) + " name: " + err.Error()
            }
        }
        if sel.Region != nil && sel.Region.Type == models.MatchRegex {
            if _, err := regexp.Compile(sel.Region.Pattern); err != nil {
                return "Invalid regex in selector " + string(rune(i+1)) + " region: " + err.Error()
            }
        }
        if sel.Engine != nil && sel.Engine.Type == models.MatchRegex {
            if _, err := regexp.Compile(sel.Engine.Pattern); err != nil {
                return "Invalid regex in selector " + string(rune(i+1)) + " engine: " + err.Error()
            }
        }
        for tagKey, matcher := range sel.Tags {
            if matcher != nil && matcher.Type == models.MatchRegex {
                if _, err := regexp.Compile(matcher.Pattern); err != nil {
                    return "Invalid regex in selector " + string(rune(i+1)) + " tag '" + tagKey + "': " + err.Error()
                }
            }
        }
    }
    return ""
}
```

This provides:
- MatchInstance: Main entry point for checking if instance matches selectors
- MatchSelector: Checks single selector against instance
- matchMatcher: Applies matcher pattern with type (exact, contains, prefix, suffix, regex)
- ValidateSelectors: Validates regex patterns before saving
  </action>
  <verify>
Go compiles: `go build ./...`
  </verify>
  <done>
- internal/scheduler/matcher.go exists with MatchInstance, MatchSelector, ValidateSelectors
- Go code compiles without errors
- Supports all MatchType values: exact, contains, prefix, suffix, regex
  </done>
</task>

<task type="auto">
  <name>Task 2: Add filter preview API endpoint</name>
  <files>internal/api/handlers/schedules.go</files>
  <action>
Extend `internal/api/handlers/schedules.go` to add a filter preview endpoint:

**Add import:**
```go
import "snoozeql/internal/scheduler"
```

**Add instanceStore to ScheduleHandler:**
Update the ScheduleHandler struct to include instanceStore:
```go
type ScheduleHandler struct {
    scheduleStore *store.ScheduleStore
    instanceStore *store.InstanceStore
    eventStore    *store.EventStore
}

// Update NewScheduleHandler
func NewScheduleHandler(scheduleStore *store.ScheduleStore, instanceStore *store.InstanceStore, eventStore *store.EventStore) *ScheduleHandler {
    return &ScheduleHandler{
        scheduleStore: scheduleStore,
        instanceStore: instanceStore,
        eventStore:    eventStore,
    }
}
```

**Add new handler method:**
```go
// PreviewFilter returns instances matching the given selectors
// POST /api/v1/schedules/preview-filter
func (h *ScheduleHandler) PreviewFilter(w http.ResponseWriter, r *http.Request) {
    var req struct {
        Selectors []models.Selector `json:"selectors"`
        Operator  string            `json:"operator"` // "and" or "or", default "and"
    }
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusBadRequest)
        json.NewEncoder(w).Encode(map[string]string{"error": "Invalid request body"})
        return
    }
    
    // Default to "and" if not specified
    if req.Operator == "" {
        req.Operator = "and"
    }
    
    // Validate operator
    if req.Operator != "and" && req.Operator != "or" {
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusBadRequest)
        json.NewEncoder(w).Encode(map[string]string{"error": "Operator must be 'and' or 'or'"})
        return
    }
    
    // Validate selectors
    if errMsg := scheduler.ValidateSelectors(req.Selectors); errMsg != "" {
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusBadRequest)
        json.NewEncoder(w).Encode(map[string]string{"error": errMsg})
        return
    }
    
    // Get all instances
    instances, err := h.instanceStore.ListInstances()
    if err != nil {
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusInternalServerError)
        json.NewEncoder(w).Encode(map[string]string{"error": "Failed to list instances"})
        return
    }
    
    // Filter instances
    var matched []models.Instance
    for _, inst := range instances {
        if scheduler.MatchInstance(&inst, req.Selectors, req.Operator) {
            matched = append(matched, inst)
        }
    }
    
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusOK)
    json.NewEncoder(w).Encode(map[string]any{
        "matched_count": len(matched),
        "total_count":   len(instances),
        "instances":     matched,
    })
}
```

**Update main.go router** (if needed, check where routes are registered):
- Add route: `POST /api/v1/schedules/preview-filter` -> `scheduleHandler.PreviewFilter`

Note: You'll need to find where the router is set up and add this new route. Also update where NewScheduleHandler is called to pass instanceStore.
  </action>
  <verify>
1. Go compiles: `go build ./...`
2. Check schedules.go has PreviewFilter method
  </verify>
  <done>
- PreviewFilter handler added to schedules.go
- Handler validates operator and selectors
- Handler returns matched instances with count
- Go code compiles
  </done>
</task>

<task type="auto">
  <name>Task 3: Create frontend filter utilities</name>
  <files>web/src/lib/filterUtils.ts</files>
  <action>
Create `web/src/lib/filterUtils.ts` with client-side instance filtering:

```typescript
import type { Instance, Selector } from './api';

// Match types that mirror backend models.MatchType
export type MatchType = 'exact' | 'contains' | 'prefix' | 'suffix' | 'regex';

export interface Matcher {
  pattern: string;
  type: MatchType;
}

/**
 * Check if an instance matches a set of selectors
 * @param instance The instance to check
 * @param selectors Array of selectors to match against
 * @param operator 'and' (all must match) or 'or' (any must match)
 * @returns true if instance matches
 */
export function matchInstance(
  instance: Instance,
  selectors: Selector[],
  operator: 'and' | 'or' = 'and'
): boolean {
  if (selectors.length === 0) {
    return false; // Require at least one selector
  }

  for (const selector of selectors) {
    const matches = matchSelector(instance, selector);
    if (operator === 'or' && matches) {
      return true;
    }
    if (operator === 'and' && !matches) {
      return false;
    }
  }

  return operator === 'and';
}

/**
 * Check if an instance matches a single selector
 * All non-null fields in the selector must match (AND within selector)
 */
export function matchSelector(instance: Instance, selector: Selector): boolean {
  // Check name matcher
  if (selector.name?.pattern) {
    if (!matchField(instance.name, selector.name)) {
      return false;
    }
  }

  // Check provider (exact match: "aws" or "gcp")
  if (selector.provider) {
    const instanceProvider = instance.provider.startsWith('aws') ? 'aws' : 'gcp';
    if (selector.provider !== instanceProvider) {
      return false;
    }
  }

  // Check region matcher
  if (selector.region?.pattern) {
    if (!matchField(instance.region, selector.region)) {
      return false;
    }
  }

  // Check engine matcher
  if (selector.engine?.pattern) {
    if (!matchField(instance.engine, selector.engine)) {
      return false;
    }
  }

  // Check tags (all specified tags must match)
  if (selector.tags) {
    for (const [tagKey, matcher] of Object.entries(selector.tags)) {
      if (!matcher?.pattern) continue;
      const tagValue = instance.tags?.[tagKey];
      if (!tagValue || !matchField(tagValue, matcher)) {
        return false;
      }
    }
  }

  return true;
}

/**
 * Apply a matcher pattern to a string value
 */
export function matchField(
  value: string,
  matcher: { pattern: string; type: string }
): boolean {
  if (!matcher || !matcher.pattern) {
    return true;
  }

  switch (matcher.type) {
    case 'exact':
      return value === matcher.pattern;
    case 'contains':
      return value.toLowerCase().includes(matcher.pattern.toLowerCase());
    case 'prefix':
      return value.toLowerCase().startsWith(matcher.pattern.toLowerCase());
    case 'suffix':
      return value.toLowerCase().endsWith(matcher.pattern.toLowerCase());
    case 'regex':
      try {
        const re = new RegExp(matcher.pattern, 'i');
        return re.test(value);
      } catch {
        return false;
      }
    default:
      return false;
  }
}

/**
 * Validate a regex pattern
 * @returns Error message if invalid, empty string if valid
 */
export function validateRegex(pattern: string): string {
  if (!pattern) return '';
  try {
    new RegExp(pattern);
    return '';
  } catch (e) {
    return e instanceof Error ? e.message : 'Invalid regex';
  }
}

/**
 * Create an empty selector with default values
 */
export function createEmptySelector(): Selector {
  return {
    name: { pattern: '', type: 'contains' },
  };
}

/**
 * Get human-readable description of a selector
 */
export function describeSelectorRule(selector: Selector): string {
  const parts: string[] = [];

  if (selector.name?.pattern) {
    parts.push(`name ${describeMatchType(selector.name.type)} "${selector.name.pattern}"`);
  }
  if (selector.provider) {
    parts.push(`provider is ${selector.provider.toUpperCase()}`);
  }
  if (selector.region?.pattern) {
    parts.push(`region ${describeMatchType(selector.region.type)} "${selector.region.pattern}"`);
  }
  if (selector.engine?.pattern) {
    parts.push(`engine ${describeMatchType(selector.engine.type)} "${selector.engine.pattern}"`);
  }
  if (selector.tags) {
    for (const [key, matcher] of Object.entries(selector.tags)) {
      if (matcher?.pattern) {
        parts.push(`tag "${key}" ${describeMatchType(matcher.type)} "${matcher.pattern}"`);
      }
    }
  }

  return parts.length > 0 ? parts.join(' AND ') : 'No conditions';
}

function describeMatchType(type: string): string {
  switch (type) {
    case 'exact':
      return 'equals';
    case 'contains':
      return 'contains';
    case 'prefix':
      return 'starts with';
    case 'suffix':
      return 'ends with';
    case 'regex':
      return 'matches';
    default:
      return type;
  }
}
```

This provides:
- matchInstance: Main filter function matching backend behavior
- matchSelector: Single selector matching
- matchField: Pattern matching with type support
- validateRegex: Frontend regex validation
- createEmptySelector: Helper for creating new selectors
- describeSelectorRule: Human-readable rule descriptions
  </action>
  <verify>
TypeScript compiles: `cd web && npx tsc --noEmit`
  </verify>
  <done>
- web/src/lib/filterUtils.ts exists
- Exports matchInstance, matchSelector, matchField, validateRegex
- Matches logic mirrors backend Go implementation
- TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
1. Backend compiles: `go build ./...`
2. Frontend compiles: `cd web && npx tsc --noEmit`
3. matcher.go has MatchInstance, MatchSelector, ValidateSelectors functions
4. schedules.go has PreviewFilter handler
5. filterUtils.ts exports matching utilities
</verification>

<success_criteria>
- Backend matcher logic complete and compiles
- Filter preview API endpoint added
- Frontend filter utilities match backend behavior
- All code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-advanced-schedule-filtering/04-01-SUMMARY.md`
</output>
