---
phase: 18-dual-mode-data-collection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/metrics/collector.go
  - cmd/server/main.go
autonomous: true

must_haves:
  truths:
    - "Real-time collection continues running every 15 minutes unchanged"
    - "Historical backfill runs after 7-minute startup delay"
    - "Historical backfill repeats every hour after initial run"
    - "Historical backfill fetches 3-day CloudWatch window (not 7 days)"
    - "Server startup no longer blocks on gap detection"
  artifacts:
    - path: "internal/metrics/collector.go"
      provides: "RunHistoricalBackfill method with startup delay + hourly interval"
      exports: ["RunHistoricalBackfill"]
    - path: "cmd/server/main.go"
      provides: "Non-blocking startup with dual goroutines"
      contains: "go metricsCollector.RunHistoricalBackfill"
  key_links:
    - from: "cmd/server/main.go"
      to: "internal/metrics/collector.go"
      via: "goroutine call to RunHistoricalBackfill"
      pattern: "go metricsCollector\\.RunHistoricalBackfill"
---

<objective>
Convert Phase 17's synchronous startup-only gap detection into a continuous background historical backfill system.

Purpose: Provide self-healing gap detection that runs continuously (hourly after initial startup delay), ensuring recommendations always have reliable 3-day data without blocking server startup.

Output: Dual-mode collection architecture with real-time (immediate + 15-min) and historical backfill (7-min delay + hourly) running as independent background goroutines.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-dual-mode-data-collection/18-RESEARCH.md

# Source files to modify
@internal/metrics/collector.go
@internal/metrics/retention.go
@cmd/server/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add RunHistoricalBackfill method to collector.go</name>
  <files>internal/metrics/collector.go</files>
  <action>
Add constants and new method following the RetentionCleaner pattern from retention.go:

1. Add constants after line 12 (after import block):
```go
const (
    backfillStartupDelay = 7 * time.Minute   // Wait before first backfill
    backfillInterval     = 1 * time.Hour     // Then hourly
    backfillDays         = 3                 // 3-day CloudWatch window
)
```

2. Add new `RunHistoricalBackfill` method (public, goroutine wrapper) BEFORE the existing `DetectAndFillGaps` method (around line 467):
```go
// RunHistoricalBackfill runs historical backfill on startup (delayed) + hourly
// This provides continuous self-healing gap detection for metrics data
func (c *MetricsCollector) RunHistoricalBackfill(ctx context.Context) {
    // Wait for startup delay with context awareness
    select {
    case <-ctx.Done():
        log.Println("Historical backfill shutting down before startup")
        return
    case <-time.After(backfillStartupDelay):
        // Continue to backfill
    }

    log.Println("Starting initial historical backfill...")
    
    // Run immediately after delay
    if err := c.runHistoricalBackfill(ctx); err != nil {
        log.Printf("Initial historical backfill failed: %v", err)
    }

    // Then hourly
    ticker := time.NewTicker(backfillInterval)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            log.Println("Historical backfill shutting down")
            return
        case <-ticker.C:
            log.Println("Running hourly historical backfill...")
            if err := c.runHistoricalBackfill(ctx); err != nil {
                log.Printf("Hourly historical backfill failed: %v", err)
            }
        }
    }
}
```

3. Rename existing `DetectAndFillGaps` to `runHistoricalBackfill` (private) and modify:
   - Change signature from `func (c *MetricsCollector) DetectAndFillGaps(ctx context.Context) error` to `func (c *MetricsCollector) runHistoricalBackfill(ctx context.Context) error`
   - Change the log message from "up to 7 days" to "3-day window"
   - Change the maxLookback calculation from 7 days to use the `backfillDays` constant:
     ```go
     maxLookback := time.Now().UTC().Add(-backfillDays * 24 * time.Hour)
     ```
   - Update the startup determination comment from "7 days ago" to use `backfillDays`:
     ```go
     // No previous data, go back backfillDays
     startTime = time.Now().UTC().Add(-backfillDays * 24 * time.Hour)
     ```
   - Update the cap comment from "7 days ago maximum" to "backfillDays ago maximum"

4. Keep the public `DetectAndFillGaps` method signature as a deprecated wrapper for backward compatibility (in case any tests call it):
```go
// DetectAndFillGaps is deprecated - use RunHistoricalBackfill instead
// Kept for backward compatibility with existing callers
func (c *MetricsCollector) DetectAndFillGaps(ctx context.Context) error {
    return c.runHistoricalBackfill(ctx)
}
```

Note: Follow the exact pattern from RetentionCleaner.RunContinuous() in retention.go for the goroutine structure.
  </action>
  <verify>
Run `go build ./...` to verify compilation succeeds with no errors.
  </verify>
  <done>
- RunHistoricalBackfill method exists with 7-minute startup delay and 1-hour interval
- runHistoricalBackfill (private) uses 3-day window instead of 7 days
- DetectAndFillGaps wrapper exists for backward compatibility
- Go build succeeds
  </done>
</task>

<task type="auto">
  <name>Task 2: Update main.go startup to use background historical backfill</name>
  <files>cmd/server/main.go</files>
  <action>
Modify the server startup flow around lines 213-225 to:

1. REMOVE the synchronous DetectAndFillGaps call (lines 213-216):
```go
// DELETE THESE LINES:
// Gap detection runs synchronously at startup to populate historical data
if err := metricsCollector.DetectAndFillGaps(ctx); err != nil {
    log.Printf("Warning: Gap detection returned error: %v", err)
}
```

2. After the existing `go metricsCollector.RunContinuous(ctx)` and its log line (around line 220), ADD:
```go
// Historical backfill: 7-minute delay + hourly (self-healing gap fill)
go metricsCollector.RunHistoricalBackfill(ctx)
log.Printf("✓ Started historical backfill (7-min delay, hourly interval, 3-day window)")
```

The resulting startup section should look like:
```go
// Start discovery in background
ctx := context.Background()
go discoveryService.RunContinuous(ctx)

// Start metrics collection in background (real-time: immediate + every 15 minutes)
go metricsCollector.RunContinuous(ctx)
log.Printf("✓ Started metrics collector (15-minute interval, 5-minute granularity)")

// Historical backfill: 7-minute delay + hourly (self-healing gap fill)
go metricsCollector.RunHistoricalBackfill(ctx)
log.Printf("✓ Started historical backfill (7-min delay, hourly interval, 3-day window)")

// Start metrics retention cleanup in background
retentionCleaner := metrics.NewRetentionCleaner(metricsStore, db)
go retentionCleaner.RunContinuous(ctx)
log.Printf("✓ Started metrics retention cleaner (7-day retention, 24h interval)")
```
  </action>
  <verify>
1. Run `go build ./cmd/server` to verify compilation
2. Run `go run ./cmd/server --help` to verify server starts (will exit after help)
3. Verify log output shows both "Started metrics collector" and "Started historical backfill" messages
  </verify>
  <done>
- Synchronous DetectAndFillGaps call removed from startup
- RunHistoricalBackfill goroutine added after RunContinuous
- Log message shows correct parameters (7-min delay, hourly interval, 3-day window)
- Server compiles and starts without blocking on gap detection
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Build verification:**
   ```bash
   go build ./...
   ```
   
2. **Server starts without blocking:**
   - Server should be ready to serve requests immediately (within seconds)
   - NOT blocked waiting for 7-day CloudWatch fetch to complete
   
3. **Startup logs show dual-mode:**
   - "✓ Started metrics collector (15-minute interval, 5-minute granularity)"
   - "✓ Started historical backfill (7-min delay, hourly interval, 3-day window)"
   
4. **After 7 minutes (if tested):**
   - Log shows "Starting initial historical backfill..."
   - Log shows "Backfilling metrics data from CloudWatch (3-day window)..."
</verification>

<success_criteria>
- [ ] DATA-01: Real-time collection continues every 15 minutes (RunContinuous unchanged)
- [ ] DATA-02: Historical backfill runs on startup (7-min delay) and hourly (1h interval)
- [ ] Historical backfill fetches 3-day CloudWatch window (not 7 days)
- [ ] Server startup no longer blocks on synchronous gap detection
- [ ] All Go code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/18-dual-mode-data-collection/18-01-SUMMARY.md`
</output>
