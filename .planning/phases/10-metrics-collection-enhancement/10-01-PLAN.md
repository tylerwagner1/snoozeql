---
phase: 10-metrics-collection-enhancement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/models/models.go
  - internal/metrics/cloudwatch.go
  - internal/metrics/collector.go
  - internal/metrics/memory.go
  - web/src/pages/InstanceDetailPage.tsx
autonomous: true

must_haves:
  truths:
    - "FreeableMemory metric appears in metrics_hourly table alongside CPU and Connections"
    - "Memory is displayed as percentage (not raw bytes) on Instance Details page"
    - "Unknown instance classes show 'N/A' for memory instead of crashing"
    - "Sleeping instances have explicit zero values stored in metrics"
    - "Instance details page shows 'Metrics unavailable' badge when collection fails"
  artifacts:
    - path: "internal/models/models.go"
      provides: "MetricFreeableMemory constant"
      contains: "MetricFreeableMemory"
    - path: "internal/metrics/cloudwatch.go"
      provides: "FreeableMemory field in RDSMetrics struct"
      contains: "FreeableMemory"
    - path: "internal/metrics/memory.go"
      provides: "Instance class to memory GB mapping"
      contains: "instanceClassMemoryGB"
    - path: "internal/metrics/collector.go"
      provides: "Memory percentage calculation and storage"
      contains: "MetricFreeableMemory"
    - path: "web/src/pages/InstanceDetailPage.tsx"
      provides: "Metrics unavailable badge"
      contains: "Metrics unavailable"
  key_links:
    - from: "internal/metrics/cloudwatch.go"
      to: "CloudWatch API"
      via: "GetMetricStatistics for FreeableMemory"
      pattern: "FreeableMemory"
    - from: "internal/metrics/collector.go"
      to: "internal/metrics/memory.go"
      via: "CalculateMemoryPercentage function"
      pattern: "CalculateMemoryPercentage"
---

<objective>
Add FreeableMemory metric collection to existing CloudWatch collector and display memory as percentage on Instance Details page with proper error handling.

Purpose: Complete the metrics collection foundation for v1.2 by adding memory metric alongside CPU/Connections, enabling future time-series visualization and recommendations.

Output: FreeableMemory collected every 15 minutes, stored as percentage, displayed on UI with graceful handling for unknown instance classes and collection failures.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-metrics-collection-enhancement/10-CONTEXT.md

@internal/models/models.go
@internal/metrics/cloudwatch.go
@internal/metrics/collector.go
@internal/metrics/store.go
@web/src/pages/InstanceDetailPage.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add FreeableMemory metric to CloudWatch collector with memory percentage calculation</name>
  <files>
    internal/models/models.go
    internal/metrics/cloudwatch.go
    internal/metrics/memory.go
    internal/metrics/collector.go
  </files>
  <action>
    1. In `internal/models/models.go`, add constant after existing metric constants:
       ```go
       MetricFreeableMemory = "FreeableMemory"
       ```

    2. In `internal/metrics/cloudwatch.go`:
       - Add `FreeableMemory *MetricValue` field to RDSMetrics struct (after WriteIOPS)
       - In GetRDSMetrics(), fetch FreeableMemory using same pattern as other metrics:
         ```go
         freeMemory, err := c.getMetricWithRetry(ctx, dbInstanceID, models.MetricFreeableMemory, startTime, endTime)
         if err == nil {
             metrics.FreeableMemory = freeMemory
         }
         ```

    3. Create new file `internal/metrics/memory.go` with instance class memory mapping:
       ```go
       package metrics

       // instanceClassMemoryGB maps RDS instance classes to total memory in GB
       // Based on AWS RDS documentation: https://aws.amazon.com/rds/instance-types/
       var instanceClassMemoryGB = map[string]float64{
           // T3 instances
           "db.t3.micro":  1,
           "db.t3.small":  2,
           "db.t3.medium": 4,
           "db.t3.large":  8,
           "db.t3.xlarge": 16,
           "db.t3.2xlarge": 32,
           // T4g instances (Graviton)
           "db.t4g.micro":  1,
           "db.t4g.small":  2,
           "db.t4g.medium": 4,
           "db.t4g.large":  8,
           // R5 instances
           "db.r5.large":   16,
           "db.r5.xlarge":  32,
           "db.r5.2xlarge": 64,
           "db.r5.4xlarge": 128,
           // R6g instances (Graviton)
           "db.r6g.large":  16,
           "db.r6g.xlarge": 32,
           // M5 instances
           "db.m5.large":   8,
           "db.m5.xlarge":  16,
           "db.m5.2xlarge": 32,
           "db.m5.4xlarge": 64,
           // M6g instances (Graviton)
           "db.m6g.large":  8,
           "db.m6g.xlarge": 16,
       }

       // CalculateMemoryPercentage converts FreeableMemory (bytes) to percentage available
       // Returns nil if instance class is not in the mapping
       func CalculateMemoryPercentage(instanceClass string, freeableMemoryBytes float64) *float64 {
           totalGB, ok := instanceClassMemoryGB[instanceClass]
           if !ok {
               return nil // Unknown instance class
           }
           
           totalBytes := totalGB * 1024 * 1024 * 1024
           percentAvailable := (freeableMemoryBytes / totalBytes) * 100
           return &percentAvailable
       }
       ```

    4. In `internal/metrics/collector.go`:
       - Update collectInstance() signature to accept instanceClass string
       - After storing existing metrics, add FreeableMemory storage:
         ```go
         if metrics.FreeableMemory != nil {
             // Calculate memory percentage from bytes
             pct := CalculateMemoryPercentage(instance.InstanceType, metrics.FreeableMemory.Avg)
             if pct != nil {
                 memValue := &MetricValue{Avg: *pct, Max: *pct, Min: *pct}
                 if err := c.storeMetric(ctx, instance.ID, models.MetricFreeableMemory, metrics.Timestamp, memValue); err != nil {
                     log.Printf("Failed to store FreeableMemory metric for %s: %v", instance.Name, err)
                 }
             } else {
                 log.Printf("Unknown instance class %s for %s - skipping memory percentage", instance.InstanceType, instance.Name)
             }
         }
         ```
       
       - Update the sleeping instance handling: Instead of skipping stopped instances entirely (lines 87-91), store zeros for them:
         ```go
         // For stopped instances, store zeros (shows "asleep" state in metrics)
         if instance.Status == "stopped" {
             if err := c.storeZeroMetrics(ctx, instance); err != nil {
                 log.Printf("Failed to store zero metrics for stopped instance %s: %v", instance.Name, err)
             }
             collected++
             continue
         }
         ```
       
       - Add helper function storeZeroMetrics():
         ```go
         func (c *MetricsCollector) storeZeroMetrics(ctx context.Context, instance models.Instance) error {
             zeroValue := &MetricValue{Avg: 0, Max: 0, Min: 0}
             timestamp := time.Now().UTC().Truncate(time.Hour)
             
             for _, metricName := range []string{
                 models.MetricCPUUtilization,
                 models.MetricDatabaseConnections,
                 models.MetricFreeableMemory,
             } {
                 if err := c.storeMetric(ctx, instance.ID, metricName, timestamp, zeroValue); err != nil {
                     return fmt.Errorf("failed to store zero %s: %w", metricName, err)
                 }
             }
             return nil
         }
         ```
  </action>
  <verify>
    Run `go build ./...` to verify compilation.
    Check that new memory.go file exists with mapping.
    Verify models.go has MetricFreeableMemory constant.
  </verify>
  <done>
    - MetricFreeableMemory constant added to models.go
    - FreeableMemory field added to RDSMetrics struct
    - memory.go contains instance class -> GB mapping (~20 entries)
    - collector.go calculates percentage and stores it
    - Stopped instances get zero metrics stored
    - Code compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add "Metrics unavailable" badge to Instance Details UI</name>
  <files>
    web/src/pages/InstanceDetailPage.tsx
  </files>
  <action>
    Update InstanceDetailPage.tsx to show a "Metrics unavailable" badge when:
    - No metrics exist for the instance, OR
    - The latest metric is older than 30 minutes (missed collection)

    1. Add badge logic after the metrics section heading (around line 219):
       ```tsx
       // Check if metrics are stale (no data or older than 30 min)
       const isMetricsStale = () => {
         if (metrics.length === 0) return true;
         const latestMetric = metrics.reduce((latest, m) => {
           const mTime = new Date(m.hour).getTime();
           return mTime > latest ? mTime : latest;
         }, 0);
         const thirtyMinutesAgo = Date.now() - (30 * 60 * 1000);
         return latestMetric < thirtyMinutesAgo;
       };
       ```

    2. Update the Metrics section header to include badge:
       ```tsx
       <div className="flex items-center justify-between mb-4">
         <h2 className="text-lg font-semibold text-gray-900">Metrics</h2>
         {isMetricsStale() && instance.status !== 'stopped' && (
           <span className="px-2 py-1 text-xs font-medium bg-yellow-100 text-yellow-800 rounded-full">
             Metrics unavailable
           </span>
         )}
       </div>
       ```

    3. Update the Memory metric card to look for 'freeablememory' (lowercase) instead of memoryutilization:
       ```tsx
       <MetricCard 
         label="Memory Available" 
         value={getMetricValue(metrics, 'freeablememory')}
         unit="%"
         min={getMetricMin(metrics, 'freeablememory')}
         max={getMetricMax(metrics, 'freeablememory')}
         samples={getMetricSamples(metrics, 'freeablememory')}
       />
       ```

    Note: The UI already handles missing metrics gracefully (MetricCard returns null if no value).
  </action>
  <verify>
    Run `cd web && npm run build` to verify TypeScript compilation.
    Visually inspect: The Memory card should show "Memory Available" with % unit.
    The yellow "Metrics unavailable" badge should appear when no recent metrics exist.
  </verify>
  <done>
    - isMetricsStale() helper function added
    - Yellow "Metrics unavailable" badge shows when metrics are stale/missing
    - Badge hidden for stopped instances (expected to have no metrics)
    - Memory metric card updated to look for 'freeablememory'
    - Frontend builds without errors
  </done>
</task>

</tasks>

<verification>
1. **Build verification:**
   - `go build ./...` passes
   - `cd web && npm run build` passes

2. **Code inspection:**
   - models.go has `MetricFreeableMemory = "FreeableMemory"` constant
   - cloudwatch.go fetches FreeableMemory from CloudWatch
   - memory.go has ~20 instance class mappings
   - collector.go calculates percentage and stores zeros for stopped instances
   - InstanceDetailPage.tsx has "Metrics unavailable" badge logic

3. **Runtime verification (if app is running):**
   - Check logs for "Metrics collection complete" showing collected count
   - Query: `SELECT DISTINCT metric_name FROM metrics_hourly;` should include FreeableMemory
   - Visit Instance Details page - Memory Available card should appear with % value
</verification>

<success_criteria>
1. FreeableMemory metric stored in metrics_hourly table as percentage (0-100)
2. Stopped instances have zero metrics stored (not skipped)
3. Unknown instance classes log warning but don't crash
4. Instance Details page shows "Memory Available" card with % unit
5. Yellow "Metrics unavailable" badge appears when no recent metrics
6. All code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/10-metrics-collection-enhancement/10-01-SUMMARY.md`
</output>
