---
phase: 14-grouped-recommendations
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - web/src/lib/api.ts
  - web/src/components/RecommendationGroup.tsx
  - web/src/pages/RecommendationsPage.tsx
autonomous: true

must_haves:
  truths:
    - "User sees recommendations organized into pattern groups"
    - "Each group shows pattern description and total savings"
    - "User can expand/collapse groups to see member instances"
    - "Single-instance groups render as regular cards without group wrapper"
    - "Per-instance savings still visible within groups"
  artifacts:
    - path: "web/src/components/RecommendationGroup.tsx"
      provides: "Group display component"
      min_lines: 40
    - path: "web/src/lib/api.ts"
      provides: "GroupedRecommendationsResponse type"
      contains: "RecommendationGroup"
    - path: "web/src/pages/RecommendationsPage.tsx"
      provides: "Grouped rendering logic"
      contains: "RecommendationGroup"
  key_links:
    - from: "web/src/pages/RecommendationsPage.tsx"
      to: "api.getRecommendations"
      via: "fetch with new response type"
      pattern: "groups"
    - from: "web/src/pages/RecommendationsPage.tsx"
      to: "web/src/components/RecommendationGroup.tsx"
      via: "import and render"
      pattern: "RecommendationGroup"
---

<objective>
Update recommendations UI to display grouped recommendations with expand/collapse

Purpose: Users can see similar idle patterns grouped together with aggregate savings (REC-02, REC-03)
Output: Grouped recommendations view with pattern descriptions, total savings per group, and expandable instance lists
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-grouped-recommendations/14-RESEARCH.md
@.planning/phases/14-grouped-recommendations/14-01-SUMMARY.md

@web/src/lib/api.ts
@web/src/components/RecommendationCard.tsx
@web/src/pages/RecommendationsPage.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update API types for grouped response</name>
  <files>web/src/lib/api.ts</files>
  <action>
Add new types and update getRecommendations return type:

1. Add RecommendationGroup interface (after RecommendationEnriched):
```typescript
export interface RecommendationGroup {
  pattern_description: string
  pattern_key: string
  total_daily_savings: number
  instance_count: number
  recommendations: RecommendationEnriched[]
}

export interface GroupedRecommendationsResponse {
  groups: RecommendationGroup[]
}
```

2. Update getRecommendations to return the new type:
```typescript
getRecommendations: (status?: string) => {
  const params = status ? `?status=${status}` : ''
  return api.get<GroupedRecommendationsResponse>(`/recommendations${params}`)
},
```

Note: This is a breaking change - the return type changes from RecommendationEnriched[] to GroupedRecommendationsResponse.
  </action>
  <verify>TypeScript compiles: `cd web && npm run build 2>&1 | head -20` (will show type errors in components - that's expected)</verify>
  <done>API types updated for grouped response structure</done>
</task>

<task type="auto">
  <name>Task 2: Create RecommendationGroup component</name>
  <files>web/src/components/RecommendationGroup.tsx</files>
  <action>
Create new component for displaying a recommendation group:

```typescript
import { useState } from 'react'
import { ChevronDown, ChevronUp, Users } from 'lucide-react'
import type { RecommendationGroup as RecommendationGroupType, RecommendationEnriched } from '../lib/api'
import { RecommendationCard } from './RecommendationCard'

interface RecommendationGroupProps {
  group: RecommendationGroupType
  onOpenModal: (rec: RecommendationEnriched) => void
  onDismiss: (id: string) => void
}

export function RecommendationGroup({ group, onOpenModal, onDismiss }: RecommendationGroupProps) {
  const [expanded, setExpanded] = useState(true) // Start expanded

  // Single-instance groups render as regular cards
  if (group.instance_count === 1) {
    return (
      <RecommendationCard
        recommendation={group.recommendations[0]}
        onOpenModal={onOpenModal}
        onDismiss={onDismiss}
      />
    )
  }

  return (
    <div className="bg-slate-800/30 rounded-xl border border-slate-700 overflow-hidden">
      {/* Group header */}
      <div
        className="flex items-center justify-between p-4 cursor-pointer hover:bg-slate-700/30 transition-colors"
        onClick={() => setExpanded(!expanded)}
      >
        <div className="flex items-center gap-3">
          <Users className="h-5 w-5 text-slate-400" />
          <span className="font-medium text-white">{group.pattern_description}</span>
          <span className="text-sm text-slate-400">
            {group.instance_count} instance{group.instance_count !== 1 ? 's' : ''}
          </span>
        </div>
        <div className="flex items-center gap-4">
          <span className="text-green-400 font-semibold">
            ${group.total_daily_savings.toFixed(2)}/day total
          </span>
          {expanded ? (
            <ChevronUp className="h-4 w-4 text-slate-400" />
          ) : (
            <ChevronDown className="h-4 w-4 text-slate-400" />
          )}
        </div>
      </div>

      {/* Instance list */}
      {expanded && (
        <div className="px-4 pb-4 space-y-2">
          {group.recommendations.map(rec => (
            <RecommendationCard
              key={rec.id}
              recommendation={rec}
              onOpenModal={onOpenModal}
              onDismiss={onDismiss}
            />
          ))}
        </div>
      )}
    </div>
  )
}

export default RecommendationGroup
```

Key behaviors:
- Single-instance groups (instance_count === 1) render as plain RecommendationCard without group wrapper
- Multi-instance groups show header with pattern description, instance count, and total savings
- Groups start expanded by default
- Click header to expand/collapse
  </action>
  <verify>File exists and TypeScript compiles: `ls web/src/components/RecommendationGroup.tsx && cd web && npm run build 2>&1 | head -20`</verify>
  <done>RecommendationGroup component created with expand/collapse functionality</done>
</task>

<task type="auto">
  <name>Task 3: Update RecommendationsPage to render groups</name>
  <files>web/src/pages/RecommendationsPage.tsx</files>
  <action>
Update the page to work with grouped response:

1. Update imports:
```typescript
import { RecommendationGroup } from '../components/RecommendationGroup'
import type { RecommendationEnriched, RecommendationGroup as RecommendationGroupType } from '../lib/api'
```

2. Update state to store groups:
```typescript
const [groups, setGroups] = useState<RecommendationGroupType[]>([])
```

3. Update useEffect to handle grouped response:
```typescript
useEffect(() => {
  const fetchRecommendations = async () => {
    try {
      const [pendingResponse, dismissedResponse] = await Promise.all([
        api.getRecommendations('pending'),
        api.getRecommendations('dismissed')
      ])
      setGroups(pendingResponse?.groups || [])
      // Count dismissed from all groups
      const dismissedRecs = dismissedResponse?.groups?.flatMap(g => g.recommendations) || []
      setDismissedCount(dismissedRecs.length)
    } catch (err) {
      console.error('Failed to load recommendations:', err)
      toast.error('Failed to load recommendations')
    }
  }
  fetchRecommendations()
}, [])
```

4. Update handleGenerate to use groups:
```typescript
const handleGenerate = async () => {
  setGenerating(true)
  try {
    const result = await api.generateRecommendations()
    toast.success(result.message)
    const updated = await api.getRecommendations('pending')
    setGroups(updated?.groups || [])
  } catch (err: any) {
    const errorMessage = err?.response?.data?.message || err?.response?.data?.error || err?.message || 'Failed to generate recommendations'
    toast.error(errorMessage)
  } finally {
    setGenerating(false)
  }
}
```

5. Update handleDismiss to work with groups:
```typescript
const handleDismiss = async (id: string) => {
  try {
    await api.dismissRecommendation(id)
    // Remove from groups and update
    setGroups(prev => {
      const newGroups = prev.map(g => ({
        ...g,
        recommendations: g.recommendations.filter(r => r.id !== id),
        instance_count: g.recommendations.filter(r => r.id !== id).length,
        total_daily_savings: g.recommendations
          .filter(r => r.id !== id)
          .reduce((sum, r) => sum + r.estimated_daily_savings, 0)
      })).filter(g => g.instance_count > 0)
      return newGroups
    })
    setDismissedCount(prev => prev + 1)
    toast.success('Recommendation dismissed')
  } catch (err) {
    toast.error('Failed to dismiss recommendation')
  }
}
```

6. Update handleConfirm similarly:
```typescript
const handleConfirm = async (id: string) => {
  setConfirmLoading(true)
  try {
    await api.confirmRecommendation(id)
    // Remove from groups
    setGroups(prev => {
      const newGroups = prev.map(g => ({
        ...g,
        recommendations: g.recommendations.filter(r => r.id !== id),
        instance_count: g.recommendations.filter(r => r.id !== id).length,
        total_daily_savings: g.recommendations
          .filter(r => r.id !== id)
          .reduce((sum, r) => sum + r.estimated_daily_savings, 0)
      })).filter(g => g.instance_count > 0)
      return newGroups
    })
    setModalOpen(false)
    setSelectedRecommendation(null)
    toast.success('Schedule created from recommendation!')
  } catch (err) {
    toast.error('Failed to create schedule')
  } finally {
    setConfirmLoading(false)
  }
}
```

7. Calculate pending count from groups:
```typescript
const pendingCount = groups.reduce((sum, g) => sum + g.instance_count, 0)
```

8. Update the render to use groups:
Replace:
```typescript
{recommendations.map((recommendation) => (
  <RecommendationCard ... />
))}
```
With:
```typescript
{groups.map((group) => (
  <RecommendationGroup
    key={group.pattern_key}
    group={group}
    onOpenModal={handleOpenModal}
    onDismiss={handleDismiss}
  />
))}
```

9. Update the empty state check from `pending.length > 0` to `pendingCount > 0`

10. Remove the old `recommendations` state and `pending` computed value - they're replaced by `groups` and `pendingCount`.
  </action>
  <verify>
TypeScript compiles and app runs:
```bash
cd web && npm run build && npm run dev &
# Then test in browser at http://localhost:5173/recommendations
```
  </verify>
  <done>RecommendationsPage renders grouped recommendations with pattern descriptions and total savings</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd web && npm run build`
2. App runs without errors: `cd web && npm run dev`
3. Recommendations page shows groups:
   - Pattern description visible in group header
   - Total savings per group visible
   - Instance count visible
   - Click group header toggles expand/collapse
4. Single-instance groups render as regular cards (no group wrapper)
5. Dismiss/Confirm still works (recommendation removed from group)
6. Generate Recommendations still works
</verification>

<success_criteria>
- REC-02 complete: Recommendations grouped by similar idle patterns in UI
- REC-03 complete: Each recommendation displays estimated daily savings (per-instance AND per-group totals)
- Groups show human-readable pattern descriptions
- Expand/collapse works for multi-instance groups
- Single-instance groups render cleanly as cards
- All existing functionality (dismiss, confirm, generate) still works
</success_criteria>

<output>
After completion, create `.planning/phases/14-grouped-recommendations/14-02-SUMMARY.md`
</output>
